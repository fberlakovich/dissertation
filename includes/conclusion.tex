% Conclusion Chapter

This thesis explored the compiler's role \emph{beyond} optimization: as a tool for improving both the security and the reliability of software.
Throughout the thesis we showed ways in which an understanding of program semantics and compilation can enable new perspectives on security hardening and fuzzer guidance.

In \cref{part:defense}, we presented \rtwoc, a compiler-driven defense against code-reuse attacks that exploits the compiler's knowledge of stack frame geometry.
Unlike prior randomization defenses that focused primarily on code layout, \rtwoc additionally randomizes the data layout, particularly on the stack.
By inserting booby-trapped pointers that are indistinguishable from real ones, \rtwoc forces attackers to guess among decoys, increasing the difficulty of reconnaissance-based attacks.
We evaluated \rtwoc along multiple dimensions, dissecting its performance overhead and analyzing its security guarantees with empirical data.

In \cref{part:fuzzing} we explored ways to repurpose a compiler's knowledge for fuzzing.
With \lool, we presented a compiler fuzzing framework that uses the compiler's optimization log as a domain-specific coverage signal.
Rather than treating the compiler as a black box and relying on generic code coverage, \lool directly observes which optimizations the compiler performs on each input.
A genetic algorithm uses this feedback to adjust the generation parameters of a code generator.
Our evaluation on the GraalVM compiler showed that \lool outperforms both static parameter configurations and AFL-based parametric fuzzing in triggering rare optimizations.

Finally, we introduced \gls{PSP}, a technique that leverages compiler analyses to expose hidden program state to coverage-guided fuzzers.
The insight behind \gls{PSP} is that sophisticated analyses already present in compilers, such as devirtualization or value-range analysis, can project their results onto the program's control-flow.
Such additional control flow could serve as intermediate stepping stones for coverage-guided fuzzers.
Our evaluation on FuzzBench and Magma benchmarks, however, did not show a statistically significant improvement in coverage or bug finding, suggesting that the tested heuristics are insufficient or that longer campaigns and different benchmark characteristics are needed.
Despite the negative empirical result, we believe the underlying principle merits further investigation with refined heuristics.
