% Conclusion Chapter

This thesis explored the compiler's role \emph{beyond} optimization: as a tool for improving both the security and the reliability of software.
The unifying insight is that compilers possess semantic knowledge---about program structure, data layout, optimization decisions, and control-flow dependencies---that is difficult or impossible to recover after compilation.
By leveraging this knowledge, we can achieve hardening and testing capabilities that are hard to implement post-compilation.

In Part~\ref{part:defense}, we presented \rtwoc, a compiler-driven defense against code-reuse attacks that exploits the compiler's knowledge of stack frame geometry.
Unlike prior randomization defenses that focused primarily on code layout, \rtwoc additionally randomizes the datalayout, particularly on the stack.
By inserting booby-trapped pointers that are indistinguishable from real ones, \rtwoc forces attackers to guess among decoys, increasing the difficulty of reconnaissance-based attacks.
We evaluated \rtwoc along multiple dimensions, dissecting its performance overhead and analyzing its security guarantees with empirical data.

In \cref{part:fuzzing} we explored ways to repurpose a compiler's knowledge for fuzzing.
With \lool, we presented a compiler fuzzing framework that uses the compiler's optimization log as a domain-specific coverage signal.
Rather than treating the compiler as a black box and relying on generic code coverage, \lool directly observes which optimizations the compiler performs on each input.
A genetic algorithm uses this feedback to adjust the generation parameters of a code generator.
Our evaluation on the GraalVM compiler showed that \lool outperforms both static parameter configurations and AFL-based parametric fuzzing in triggering rare optimizations.

Finally, we introduced \gls{PSP}, a technique that leverages compiler analyses to expose hidden program state to coverage-guided fuzzers.
The insight behind \gls{PSP} is that sophisticated analyses already present in compilers, such as devirtualization or value-range analysis, can project their results onto the program's control-flow.
Such additional control flow could serve as intermediate stepping stones for coverage-guided fuzzers.
Our evaluation on FuzzBench and Magma benchmarks, however, did not show a statistically significant improvement in coverage or bug finding, suggesting that the tested heuristics are insufficient or that longer campaigns and different benchmark characteristics are needed.
Despite the negative empirical result, we believe the underlying principle merits further investigation with refined heuristics.
