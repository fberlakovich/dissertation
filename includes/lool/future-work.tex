\section{Possible Extensions}
\subsection{Compiler optimization logs}\label{lool:ss:other-opt-logs}
Our approach to guided fuzzing should apply to any mature compiler that saves information about the optimizations it performed.

The optimization log closest to the Graal compiler's optimization log is V8's TurboFan optimization trace.
The trace contains the graph nodes before and after each performed optimization for each method.
Several other compilers produce some form of optimization log as well, such as LLVM's Remarks\footnote{\url{https://llvm.org/docs/Remarks.html}} or the Intel Compiler's Optimization Reports\footnote{\url{https://www.intel.com/content/www/us/en/developer/articles/technical/getting-the-most-out-of-your-compiler-with-new-optimization-reports.html}}.
In contrast to GraalVM's optimization log, these compilers also include \emph{negative} entries in the log for optimizations that were attempted but did not succeed or were not considered profitable.
This information could help the fuzzer to gradually approach an input code shape that eventually triggers the optimization.

Other compilers, such as GCC, do not produce such structured logs.
As an alternative to an explicit structured log, debug dumps of the program state before and after compiler phases could be compared to infer if an optimization has taken place.
This would also provide a form of optimization coverage information suitable for use as feedback to a fuzzer.
However, if a structured log proves to be helpful for fuzzing, it should be easy for compiler developers to retrofit the required logging in their compilers.
