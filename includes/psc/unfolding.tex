\section{Unfolding Dynamic Calls}
In \cref{psc:sec:motivation} we discussed how \aflpp's compiler instrumentation for code coverage loses information at indirect call sites.
The reason is that code coverage instrumentation cannot differentiate the dynamic edges of a indirect call site.
An analysis called \emph{points-to} analysis can, however, determine these edges at compile time.
Compilers use this analysis for both security and performance transformations.
Various \gls{CFI} variants, for example, use static points-to analysis to determine the possible target set for indirect calls (see \cref{ch:code-reuse-coevolution} for a discussion of \gls{CFI}).
Likewise, when a compiler can statically prove that in a given program an indirect call site can only ever have a single target, the compiler can transform the indirect call into a direct call.
Such a conversion enables additional optimizations later in the optimization pipeline, such as inlining.

\glspl{JITcomp} perform a similar optimization, typically based on profiling information.
In a transformation called \emph{polymorphic inlining}, \glspl{JITcomp} rewrite polymorphic call sites to exploit the usually high type stability of call sites.
For example, consider the Java Program in \cref{psc:lst:polymorphic-call}.
\begin{listing}
    \centering
    \begin{minted}[mathescape]{Java}
abstract class Animal { public void makeSound(); }
class Cat extends Animal  { public void makeSound() {$\dots$} }
class Dog extends Animal  { public void makeSound() {$\dots$} }
class Elephant extends Animal  { public void makeSound() {$\dots$} }

Animal[] animals = {new Dog(), new Cat()};
for (int i=0; i<1000; i++) {
    Animal animal = animals[i % animals.length];
    animal.makeSound(); $\label{psc:line:polymorphic-call}$
}
    \end{minted}
    \label{psc:lst:polymorphic-call}
\end{listing}

The polymorphic call site in \cref{psc:line:polymorphic-call} calls either \code{Cat}'s or \code{Dog}'s implementation of \code{makeSound}.
On the assembly level, the call site looks like in \cref{psc:lst:vcall-pseudocode}.
\begin{listing}
    \centering
    \begin{minted}{gas}
; assuming a pointer to animal is loaded in rdi
mov     rax, [rdi]         ; load vptr from object
mov     rax, [rax]         ; load function pointer for makeSound from vtable slot 0
call    rax                ; indirect call through the function pointer
ret
    \end{minted}
    \label{psc:lst:vcall-pseudocode}
\end{listing}

After an initial profiling period, the \gls{JITcomp} detects the type stability of the polymorphic call site and might transform the call site into the code in \cref{psc:lst:polymorphic-inlining}.
In case of multiple possible targets, the \gls{JITcomp} typically orders the direct calls based on their observed frequency, with the most frequent at the top.
Note that \glspl{JITcomp} typically avoid rewriting the code itself and instead cache a direct pointer to the target function in what is called an inline cache.
The principal idea behind the transformation stays the same, however.
\begin{listing}
    \centering
    \begin{minted}[mathescape]{gas}
; assuming a pointer to animal is loaded in rdi
mov     rax, [rdi]         ; load vptr from object

; --- Check for Cat's vtable ---
cmp     rax, <Cat Vtable Location>
je      .Lcat_fastpath

; --- Check for Dog's vtable ---
cmp     rax, <Dog Vtable Location>
je      .Ldog_fastpath

; --- Fallback: generic virtual call ---
mov     rax, [rdi]         ; load vptr from object
mov     rax, [rax]         ; load function pointer for makeSound from vtable slot 0
call    rax                ; indirect call through the function pointer
ret

; --------- Fast paths ---------
.Lcat_fastpath:
call Cat::makeSound
ret

.Ldog_fastpath:
call Dog::makeSound
ret
    \end{minted}
\label{psc:lst:polymorphic-inlining}
\end{listing}

For \gls{AOT} compilers, this transformation is more challenging because of the lack of runtime profiling information.
Nonetheless, \gls{AOT} compilers can apply the transformation either heuristically or because they can prove based on dataflow that only certain types can reach a polymorphic call site.
The fallback option that performs an indirect call guarantees that the program remains correct even if the analysis or the profiling information is incomplete.
In the context of object-oriented languages, an analysis called \emph{class hierarchy analysis} provides an upper bound on which call targets are possible at a call site based on the object's static type.
A polymorphic call site with static type \propername{A} that calls a method \propername{M} can only reach implementations of \propername{M} within \propername{A}'s type hierarchy.
For generic indirect calls, restricting the set of possible call targets is harder.
Since points-to analysis in general and points-to analysis for indirect calls in particular is a common issue, a range of solutions exist with different tradeoffs.

The afforded performance improvement depends on the quality of the heuristics or the available profiling information.
SafeDispatch, a defense against vtable hijacking, uses the same technique to harden \cpp programs~\cite{jang2014}.
Performance aside, we observe that this type of transformation has another important property: it projects a data dependency---which concrete object reaches a call site---onto the control-flow graph.
In other words, possible variations in data, at least some of them, are now represented in the \gls{CFG}.
A representation as control-flow allows \aflpp's coverage instrumentation to instrument the previously invisible dynamic edges.
We call this principle \emph{Program State Convolution} or \glsshortkey{PSC} for short, because it combines control flow with parts of the program's hidden state.

\begin{listing}
    \begin{minted}{cpp}
#include <iostream>
#include <vector>
#include <fstream>

class Shape { public: virtual void draw(int scale) = 0; };
class ShapeParser { public: virtual Shape *parse(std::string pattern) = 0; };

class Rectangle : public Shape {
public:
  void draw(int scale) override {
    std::cout << "[Rectangle] scaled size: " << 10 / (scale + 1) << std::endl;
  }
};

class Circle : public Shape {
public:
  void draw(int scale) override {
    // BUG when scale == 0
    std::cout << "[Circle] scaled size: " << 10 / scale << std::endl;
  }
};

class CircleParser : public ShapeParser {
public:
  Shape *parse(std::string pattern) override { return pattern == "circle" ? new Circle() : nullptr; }
};

class RectangleParser : public ShapeParser {
public:
  Shape *parse(std::string pattern) override { return pattern == "rectangle" ? new Rectangle() : nullptr; }
};

int main(int argc, char *argv[]) {
  std::vector<ShapeParser *> shapeParsers = {new RectangleParser(), new CircleParser()};
  std::vector<Shape *> parsedShapes;
  std::string filename1 = argv[1];
  std::ifstream stream(filename);
  for (std::string line; std::getline(stream, line);)
    for (auto parser : shapeParsers)
      if (Shape *parsed = parser->parse(line)) parsedShapes.push_back(parsed);

  for (auto shape : parsedShapes) shape->draw(5);

  // filter parsedShapes somehow

  for (auto shape : parsedShapes) shape->draw(0); $\label{psc:line:broken-draw-call}
}
    \end{minted}
    \label{psc:lst:vcall-dependence}
\end{listing}

\cref{psc:lst:vcall-dependence} shows a simple polymorphic call example in \cpp.
The code consists of parser objects that populate a list of shapes depending on the strings found in an input file.
After initially drawing the shapes with a scale of $5$, the code filters the list of shapes.
In a second loop, the code draws the shapes with a scale of $0$, which works for rectangles but crashes for circles.
Whether the bug is hit depends on the filtering logic and whether circle objects reach the call site at \cref{psc:line:broken-draw-call}.
Since the first loop might have called the \code{draw} method of both types already, compiler-based code coverage considers both methods as covered.

In contrast, \gls{PSC} would transform \cref{psc:line:broken-draw-call} conceptually as shown in \cref{psc:lst:broken-draw-call-unfolded}.
\begin{listing}
    \begin{minted}{cpp}
if (dynamic_cast<Rectangle *>(*iter))
  // call Rectangle::draw without dynamic dispatch
if (dynamic_cast<Circle *>(*iter))
  // call Circle::draw without dynamic dispatch
(*iter)->draw(5);
    \end{minted}
\end{listing}
Each added control-flow branch provides the fuzzer with a potential stepping stone to build a new seed.