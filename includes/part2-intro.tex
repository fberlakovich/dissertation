% Part II Introduction - Improving Fuzzer Guidance with Compiler Assistance

While the first part of this thesis focused on hardening deployed programs against exploitation, this part addresses the complementary goal of finding bugs before deployment.
Fuzzing has emerged as one of the most effective techniques for discovering vulnerabilities in complex software, but its effectiveness depends critically on the feedback mechanisms that guide input generation.

The compiler is uniquely positioned to bridge this gap.
Beyond the simple code coverage metrics that most fuzzers rely on, the compiler has access to rich semantic information.
By surfacing this internal state, we can transform the compiler into a collaborator in the fuzzing effort.
Whereas in \cref{part:defense} the compiler helped us to hide information from an attacker, in this part we aim to \emph{minimize the information asymmetry} between the program's internal state and the fuzzer.

\Cref{ch:fuzzer-guidance} provides background on fuzzer feedback mechanisms and their limitations.
We then present \lool, a fuzzing framework that uses the compiler's optimization log as a domain-specific coverage metric for compiler testing.
Finally, we introduce \emph{Program State Projection} (PSP), a technique that uses compiler analyses to project hidden data dependencies onto observable control flow, and evaluate its effectiveness on real-world benchmarks.
