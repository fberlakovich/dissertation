\section{Possible Extensions}

\subsection{Caller and Callee \gls{BTRA} Synchronization}\label{r2c:ss:caller-and-callee-synchronization}
In \cref{r2c:ss:impl-btras} we described how caller and callee have to agree on how much space is needed after the real return address for additional \glspl{BTRA}.
As for indirect calls the compiler cannot always determine the call target, the \rtwoc compiler tolerates occasional \gls{BTRA} overwrites.
A possibility for caller and callee to synchronize at runtime would be to base the position of the real return address on the callee's runtime address.
For example, a simple hash function could transform the caller's runtime address into a value between $0$ and $N+1$, where $N$ is the number of \glspl{BTRA} per function.
Since both the caller and the callee know the callee's address, the caller can choose the right number of \glspl{BTRA} to push and the callee knows the required stack pointer offset.
An added benefit of this approach would be that the position of the real return address changes with each program start.
Even without load-time function permutation, \gls{ASLR} moves function addresses on each program load.


\subsection{Implementation on ARM}
Our implementation of \rtwoc is based on the x86-64 architecture and aims to respect architecture-specific behavior such as that the \code{CALL} instruction automatically pushes the return address onto the stack.
The idiosyncrasy of the \code{CALL} instruction makes the \gls{BTRA} setup challenging.
Specifically, it requires the caller to properly position the stack pointer and the callee to move the stack pointer again to avoid overwriting \glspl{BTRA} (see \cref{r2c:ss:impl-btras}).
On the ARM architecture, where the return address is saved in the \code{LR}, only callees that execute a call themselves have to spill the \code{LR} register.
Spilling in the callee avoids the synchronization problem discussed in \cref{r2c:ss:caller-and-callee-synchronization}, as saving and loading the return address happens in the same function.

Another area where ARM would provide a benefit for \rtwoc over x86-64 are memory tags.
In our current implementation the \glspl{heapbt} use guard pages to cause traps upon access.
Having to allocate full pages for \glspl{heapbt} leads to heap fragmentation and makes \glspl{heapbt} easier to distinguish from regular allocations.
ARM memory tags on the other hand, have a granularity of 16 bytes.
On ARM, the \glspl{heapbt} runtime could tag small allocations on the heap with a memory tag and then use pointers with a \emph{different} tag as \glspl{heapbt}.

\subsection{Heap Mimicry}\label{r2c:ss:heap-mimicry}
As discussed in \cref{r2c:sss:heap-data}, the security guarantees of \glspl{heapbt} are limited.
The heap offers rich information to an adversary: it stores function pointers and other heap references and, in many scenarios, keeping the attacker away from heap memory is impractical.
A different approach is to extend the mimicry principle to the heap.
Similar to the idea of \glspl{BTRA} and \glspl{heapbt}, \rtwoc could penalize attempts to follow pointers of \emph{random} objects on the heap.
\rtwoc could, for instance, allocate a fake heap object for every $X$th real heap object and free one fake object on every $X$th deallocation.
Dereferencing pointers in these fake heap objects would trigger a booby trap.
An advantage of this approach is that the resulting pointers and allocation patterns very closely resemble real allocations.
To further strengthen the illusion of real heap objects, the fake heap objects could change over time, \eg through manipulation by a background thread.
To make this approach practical, two challenges have to be overcome.
First, allocation of these fake objects should not happen in hot code, such as a loop, to avoid excessive performance overhead.
Second, the fake objects should closely resemble the data structures of real heap objects used in the protected program.
For example, if a program only allocates structures with a single function pointer, then fake objects containing multiple function pointers are immediately recognizable to the attacker.
Such data structure imitation could happen based on the types used for real heap allocations.


\subsection{Speculative Booby Traps}\label{r2c:ss:speculative-booby-traps}%

\newsavebox{\speculativebt}
\begin{lrbox}{\speculativebt}

    \begin{lstlisting}[style=asmcode,frame=none,breaklines=false,basicstyle=\scriptsize\ttfamily]
<boobytrap>: |\Circled{1}|
 call set_up_target
|\tikzmark{T-Decoy-Gadget}| jmp F

set_up_target:
 mov (%rsp), target
 ret|\tikzmark{T-Ret-Alarm}|

target:
 call alarm|\tikzmark{T-Call-Alarm}|
    \end{lstlisting}
\end{lrbox}


\begin{figure}[t]
    % --- ROW 1: GRAPHICAL CONTENT ---
    % This row contains the graphics, aligned at their bottom edges.

    \begin{minipage}[b]{0.25\linewidth}
        \begin{lstlisting}[style=asmcode,basicstyle=\footnotesize\ttfamily]
call set_up_target

capture_spec:
 pause
 jmp capture_spec

set_up_target:
 mov (%rsp), %rax
 ret
        \end{lstlisting}
    \end{minipage}%
    \hfill%
    \begin{minipage}[b]{0.7\linewidth}
        \resizebox{\linewidth}{!}{
            \includeDrawioFigure{figures/r2c/btra-only-stack}[remember picture]{
                \node[anchor=north west] (CodeBox) at (Code) {\usebox\speculativebt};
                \draw[dash pattern=on 4pt off 4pt] (CodeBox.north west) rectangle (CodeBox.south east);
                \draw[dash pattern=on 2pt off 2pt] (Bomb) -- (CodeBox.north west);
                \draw[dash pattern=on 2pt off 2pt] (Bomb) -- (CodeBox.south west);
                \draw[-latex, dash dot] ([shift={(-1pt,2pt)}] pic cs:T-Decoy-Gadget) -| (Elbow) |- (ReturnInstr);
                \node[yshift={1.5*\ht\pgfnodeparttextbox}] at (Elbow) {\scriptsize{}\code{\Circled{\ttfamily2}}};
                \coordinate (RetAlarm) at ([shift={(2pt,2pt)}] pic cs:T-Ret-Alarm);
                \coordinate (RightOffset) at ($ (CodeBox.west)!.8!(CodeBox.east) $, 0);
                \coordinate (OffsetPoint) at (RightOffset |- RetAlarm);
                \draw[-latex, solid] (RetAlarm) -- (OffsetPoint) |- ([shift={(2pt,2pt)}] pic cs:T-Call-Alarm);
                \node[shift={(-\ht\pgfnodeparttextbox, -\ht\pgfnodeparttextbox)}] at (OffsetPoint)  {\scriptsize{\Circled{\ttfamily3}}};
            }
        }
    \end{minipage}

    % --- ROW 2: CAPTIONS ---
    % This row contains the captions, aligned at their top edges.
    % The \subcaption command will work inside the minipage.

    \begin{minipage}[t]{0.3\linewidth}
        \subcaption{Retpolines control the branch target speculation for indirect branches.}
        \label{lst:retpoline}
    \end{minipage}%
    \hfill%
    \begin{minipage}[t]{0.6\linewidth}
        \subcaption{A speculation aware booby trap that looks like the expected code during speculative execution.}
        \label{r2c:fig:speculation-aware-boobytrap}
    \end{minipage}
\end{figure}



Booby traps are an effective measure to deter random probing.
For booby traps to be effective, two properties must hold:
\begin{enumerate*}
    \item they must be indistinguishable from benign code from the attacker's perspective and
    \item triggering them must have negative consequences for the attacker.
\end{enumerate*}
Code-layout randomization in combination with execute-only memory ensures the first property.
The negative consequences for the attacker depend on the booby trap used, but can range from simply crashing the program over raising an alarm to launching a counter-attack~\cite{Crane2013}.
These observations hold true, however, only in the non-speculative domain.

Over the last 8 years, transient-execution attacks have opened another battleground besides the classic \glspl{CRA}.
In a transient execution attack an attacker abuses the \gls{CPU}'s speculation behavior to transiently execute potentially harmful code.
Although the code execution is only transient, such speculatively executed code leaves behind traces that an attacker can extract with a variety of methods.\fbetodo{cite cache side channels}
Apart from using this principle to directly leak sensitive information, attackers can also lift \glspl{CRA} into the speculative domain.

The Blindside attack, for example, employs the same principles as Blind ROP to speculatively locate gadgets with a technique called \emph{gadget probing}.
The idea behind gadget probing is that gadgets can be identified by their cache behavior during speculative execution.
Similarly, SpecROP~\cite{Bhattacharyya2020} executes entire gadget chains speculatively.
The speculative execution of gadgets makes these techniques immune to runtime exceptions.

An attacker could use this fault-resistant capability to either leak data or to uncover booby trap addresses.
Assume, for example, that a booby-trap function is located at address \code{0xbeef} and that the adversary leaks a stack frame with \code{0xbeef} occurring as a potential return address.
To avoid detection, the attacker speculatively executes the code at \code{0xbeef} and observes its cache behavior.
Since \code{0xbeef} points to the booby trap, the resulting cache traces differ from those of the actual return site.
Thus, speculative execution poses a threat to boob-trap functions.

Booby traps are vulnerable because
\begin{enumerate*}
    \item they exhibit the \emph{same} behavior in both, speculative and non-speculative execution;
    \item their observable behavior during speculative execution is \emph{different} from benign code.
\end{enumerate*}
Protecting booby traps against speculation requires a new approach.
We call our approach \emph{speculation-aware booby traps}, as it lifts the deceiving properties of booby traps into the speculative domain.
Although we have prototyped speculation-aware booby traps, we did not include them in the final defense, as we considered them out of scope for \rtwoc.
We present the idea here to motivate more research in that direction.

Speculation-aware booby traps build on the principle of separating speculative and non-speculative control flow.
This principle was first demonstrated by retpolines~\cite{Turner2018}, which capture speculative control-flow in a spin loop.
\cref{lst:retpoline} shows an example of a retpoline protecting an indirect branch to the address in \code{rax} against speculative execution.

Instead of a spin loop, speculation-aware booby traps redirect speculative control-flow to the code an attacker expects behind an address.
\cref{r2c:fig:speculation-aware-boobytrap} shows how speculation-aware booby traps could be used in the context of \rtwoc.
For example, if \code{0x400530} is a booby trap address and \code{0x40055d} denotes the real return address, a speculation-aware booby trap would redirect the speculative control flow to \code{0x40055d}.
The cache traces left behind by speculatively executing \code{0x400530} would, thus, reflect those of speculatively executing \code{0x40055d}.
The only way for an attacker to know for sure what code hides behind \code{0x40055d} would be to execute it non-speculatively, which would trigger the booby trap.
