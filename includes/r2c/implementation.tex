\section{The \rtwoc{} Compiler}\label{r2c:s:implementation} % maximum 2-3 pages...
We implemented \rtwoc using the LLVM compiler framework~\cite{Lattner2004}.
Our modified compiler supports the compilation of a wide range of systems software for the Linux \code{x86\_64} platform (see \cref{r2c:ss:scalability}).
To support complex applications like Webkit, \rtwoc{} is fully compatible with \gls{PIC} for ASLR, stack unwinding, and exception handling.
\rtwoc combines a multitude of different diversification techniques, including function shuffling, global variable shuffling, register-allocation randomization and NOP insertion.
In addition, \rtwoc supports two new diversification techniques that we describe in more detail in the following sections.
Specifically, our compiler
\begin{enumerate*}[label=(\roman*)]
    \item instruments call sites with booby-trapped return addresses (see \cref{r2c:ss:impl-btras});
    \item instruments functions to insert \glspl{heapbt}, which thwart the statistical analysis of pointers on the stack (see \cref{r2c:ss:impl-heap-boobytraps}).
\end{enumerate*}

\subsection{BTRAs: Booby-Trapped Return Addresses}\label{r2c:ss:impl-btras}

\newsavebox{\btrasetup}
\begin{lrbox}{\btrasetup}
    \begin{lstlisting}[style=asmcode,style=coloredrads]
push BTRA1
push BTRA2
push RA
push BTRA3 |\circledtikz{1}|
add %rsp, 0x10 |\circledtikz{2}|
call F|\tikzmark{T-Call-Setup}| |\circledtikz{3}|
add %rsp,0x10|\tikzmark{T-Add-Cleanup}| |\circleddashedtikz{7}|
    \end{lstlisting}
\end{lrbox}

\newsavebox{\btrateardown}
\begin{lrbox}{\btrateardown}
    \begin{lstlisting}[style=asmcode]
|\tikzmark{T-Function}|<F>:
sub %rsp,0x8 |\circledtikz{4}|

    |\raisebox{-1pt}[0pt][0pt]{$\vdots$}|

add %rsp,0x8 |\circleddashedtikz{5}|
|\tikzmark{T-Ret-Setup}|ret |\circleddashedtikz{6}|
    \end{lstlisting}
\end{lrbox}
\newlength{\btracodegap}
\setlength{\btracodegap}{6em}
\newlength{\btracodewidth}
\setlength{\btracodewidth}{\dimexpr\wd\btrasetup+\wd\btrateardown+\btracodegap\relax}

\begin{figure}[t]
    \begin{subfigure}[t]{\linewidth}
        \centering
        \begin{minipage}{\btracodewidth}
            \usebox\btrasetup\hspace{\btracodegap}\usebox\btrateardown
        \end{minipage}
        \caption{Cooperation between caller (\emph{left}) and callee (\emph{right}) to insert \glspl{BTRA}.}
        \label{r2c:fig:rad-insertion-code}
    \end{subfigure}
    \begin{tikzpicture}[overlay, remember picture]
        \draw[-Latex] ([shift={(18pt,2pt)}] pic cs:T-Call-Setup) -- +(1.6,0) |- ([shift={(-7pt,2pt)}] pic cs:T-Function);
        \draw[-Latex] ([shift={(-10pt,1pt)}] pic cs:T-Ret-Setup) -- ([shift={(18pt,2pt)}] pic cs:T-Add-Cleanup);
    \end{tikzpicture}
    \begin{subfigure}[t]{\linewidth}
        \centering
        \includeDrawioFigure[\linewidth]{figures/r2c/btra-setup}{
            \draw ([yshift=-10pt] Arrow1) node {\circledtikz{\code{1}}};
            \draw ([yshift=-10pt] Arrow2) node {\circledtikz{\code{2}}};
            \draw ([yshift=-10pt] Arrow3) node {\circledtikz{\code{3}}};
            \draw ([yshift=-10pt] Arrow4) node {\circledtikz{\code{4}}};
            \draw ([yshift=-10pt] Arrow5) node {\circleddashedtikz{\code{5}}};
            \draw ([yshift=-10pt] Arrow6) node {\circleddashedtikz{\code{6}}};
            \draw ([yshift=-10pt] Arrow7) node {\circleddashedtikz{\code{7}}};
        }
        \caption{Stack view of the booby-trapped return address setup and teardown process.}
        \label{r2c:fig:rad-insertion-stack}
    \end{subfigure}%
    \caption{Insertion and deletion of booby-trapped return addresses: Code perspective (\Cref{r2c:fig:rad-insertion-code}), and effect on the stack (\Cref{r2c:fig:rad-insertion-stack}).
    For brevity the figure uses only two \glspl{BTRA} before (\texttt{\gls{BTRA}1}) and (\texttt{\gls{BTRA}2}) and one \gls{BTRA} after (\texttt{\gls{BTRA}3}) the return address.}
    \label{r2c:fig:btra-insertion}
\end{figure}

% To this end, \rtwoc encloses return address with BTRAs.
To enclose return addresses with \glspl{BTRA}, steps \Circled{\code{1}} to \Circled{\code{4}} in \cref{r2c:fig:btra-insertion} are required.
First, the caller pushes randomly chosen \glspl{BTRA} together with the return address on the stack \Circled{\code{1}}.
Note that the position of the return address within the sequence of \glspl{BTRA} is chosen randomly at compile time.
Second, the caller positions the stack pointer above the return address \Circled{\code{2}}.
Third, the caller executes the \texttt{call} instruction \Circled{\code{3}}.
On x86, \texttt{call} instructions implicitly perform two operations:
\begin{enumerate*}[label=(\roman*)]
    \item write the return address to the current stack pointer position;
    \item transfer control to the callee.
\end{enumerate*}
Due to the prior positioning of the stack pointer, the call instruction overwrites the return address already on the stack.
Put differently, the addresses on the stack \emph{do not change} after step \Circled{\code{1}}.
Writing all the addresses to the stack at once eliminates the possibility for a race condition window during which an attacker could observe stack changes.
If, for example, only the \glspl{BTRA} were inserted before the call, the attacker could learn the return address by observing the stack right before and after the call instruction~\cite{Pomonis2017}.
While such a precise timing might seem unattainable in practice, a similar race-condition attack forced Microsoft to rethink their Return Flow Guard architecture~\cite{Bialek2018}.

The position of the return address chosen by the \emph{caller} defines how many \glspl{BTRA} \emph{precede} the return address.
The preceding \glspl{BTRA} create an offset between the return address and caller stack objects (\eg local variables in the caller).
We call the resulting offset \emph{pre-offset}.

After the control-flow transfer, the stack pointer points directly below the return address, still pointing into the \gls{BTRA} sequence.
Subsequent register spills in the callee would, therefore, overwrite \glspl{BTRA} below the return address.
To avoid overwriting the \glspl{BTRA}, in the last step the callee decreases the stack pointer by a random offset \Circled{\code{4}}.
The random offset chosen by the \emph{callee} defines the number of \glspl{BTRA} that \emph{succeed} the return address.
The succeeding \glspl{BTRA} create an offset between the return address and callee stack objects (\eg spilled registers).
This resulting offset is called a \emph{post-offset}.

After adjusting the stack pointer, the callee executes the regular function prologue.
When reaching the epilogue of the callee, the setup process is reversed as shown in \cref{r2c:fig:btra-insertion}, steps \circleddashedtikz{\code{5}} to \circleddashedtikz{\code{7}}.
First, to identify the correct return address, the callee reverts the post-offset \circleddashedtikz{\code{5}} before executing the return instruction.
Next, the return instruction pops the return address from the stack \circleddashedtikz{\code{6}} and transfers control back to the caller.
Finally, the caller reverts the pre-offset \circleddashedtikz{\code{7}}, which is required to perform stack-relative operations, such as referencing spilled local variables or function parameters.

Since the caller chooses the \emph{number} of \glspl{BTRA} to push and the \emph{pre-offset}, while the callee chooses the \emph{post-offset}, caller and callee cooperate in the setup of \glspl{BTRA}.
For direct call sites, \rtwoc bounds the number of \glspl{BTRA} after the return address at compile-time to fit into the \emph{post-offset}.
For indirect call sites, no synchronization between the caller and the callee is possible at compile time.
Instead, we tolerate that the caller potentially overwrites \glspl{BTRA} after the return address.
Per default, \rtwoc does not add \glspl{BTRA} to call sites that call unprotected code.
While adding \glspl{BTRA} would not harm functionality, unprotected callees would overwrite \emph{all} \glspl{BTRA} after the return address.
We discuss the security implications in \cref{r2c:ss:limitations-coverage}.
Our \glspl{BTRA} implementation cooperates with ThinLTO to match as many caller-callee pairs at compile time as possible.

Emitting the setup code for \glspl{BTRA} happens in a target-specific pass.
This pass is also responsible for inserting the boobytrap functions to which the \glspl{BTRA} point.
In the current implementation, a boobytrap function simply jumps to a notification routine.
A refined implementation could let the \glspl{BTRA} point to boobytrap regions \emph{within} the caller function.
Depending on the relocation model and the setup instructions, the \glspl{BTRA} are either embedded in the \code{push} instructions or read from the data section.
Since an attacker cannot predictably identify the return address among the \glspl{BTRA}, storing the addresses in the data section does not compromise security.

If the randomly chosen number of \glspl{BTRA} before the return address is odd, \rtwoc{} inserts an additional \gls{BTRA} to keep the stack aligned.
On x86-64, the stack pointer must be 16-byte aligned, as programs crash when certain instructions access a misaligned stack.

\subsubsection{Stack Arguments}\label{r2c:sss:stack-arguments}

\begin{figure}[t]
    \centering
    \begin{subfigure}[t]{0.3\linewidth}
        \centering
        \includegraphics[width=0.9\linewidth]{figures/r2c/parameter-addressing-plain}
        \caption{Without \cfs the base pointer points below the spilled base pointer.}
        \label{r2c:fig:stack-arguments}
    \end{subfigure}
    \quad
    \begin{subfigure}[t]{0.3\linewidth}
        \centering
        \includegraphics[width=0.9\linewidth]{figures/r2c/parameter-addressing-btra}
        \caption{With \cfs the caller positions the base pointer below the first stack argument.}
        \label{r2c:fig:stack-arguments-with-btras}
    \end{subfigure}
    \caption{\rtwoc{} uses \cfs{} to account for the dynamic offset introduced by \glspl{BTRA}.}
\end{figure}

The \glspl{BTRA} inserted by \rtwoc change the distance between stack objects above and below the return address.
In particular, the distance increases by the sum of pre- and post-offset.
This increased distance typically does not cause any compatibility issues because most functions do not access stack objects above their return address.
With one notable exception:
In the System V ABI a caller must pass arguments that do not fit into parameter registers on the stack, \emph{above} the return address.
Consider, for example, the stack arguments in the stack frame in \cref{r2c:fig:stack-arguments}.
The argument values \code{0x7} and \code{0x8} are located above the return address in the illustrated stack frame.
LLVM uses either the frame pointer, or the stack pointer as an anchor to access stack arguments.
Which pointer is actually used depends on the optimization level and several other factors.
Functions that need stack realignment, for example, cannot use the stack pointer for addressing stack arguments.
Without \glspl{BTRA}, the compiler determines the distance between a stack argument and the anchor statically.
With \glspl{BTRA}, however, the distance is not known at compile-time.
Although pre-offset and post-offset are chosen at compile-time, the pre-offset can be different for each call site.
As a result, the distance---i.e., the sum of pre-offset and post-offset---depends not only on the function but also its caller.


To access stack arguments despite the varying distance, we devised a method called \emph{\cfs}.
\Cfs moves the setup of the frame pointer from the function prologue to the call site.
In particular, the caller positions the frame pointer \emph{before} the varying pre-offset (see \cref{r2c:fig:stack-arguments-with-btras} for an illustration).
Thus, the distance between the frame pointer and the stack arguments can be computed statically.
In the callee we omit the frame pointer setup, and use the already prepared frame pointer to access stack arguments.

\Cfs is required for all functions using both \glspl{BTRA} and stack arguments.
As \cfs requires a frame pointer, it inhibits an optimization called frame-pointer omission.
Frame-pointer omission re-purposes the frame register as a general purpose register and addresses all stack arguments via the stack pointer instead.
We discuss the introduced performance overhead in \cref{sec:r2c:evaluation}.

\subsubsection{Optimization with AVX2}
\begin{figure}[t]
        % --- ROW 1: GRAPHICAL CONTENT ---
        % This row contains the graphics, aligned at their bottom edges.

    \begin{minipage}[b]{0.4\linewidth}
        \begin{lstlisting}[style=asmcode,style=coloredrads]
vmovdqa %ymm13,(arr) |\tikzmark{T-First-Vex-Mov}|
vmovdqu -0x20(%rsp),%ymm13
vmovdqa %ymm13,0x20(arr) |\tikzmark{T-Second-Vex-Mov}|
vmovdqu -0x40(%rsp),%ymm13
vzeroupper
sub $0x30,%rsp
call callee
        \end{lstlisting}
        \vspace{1cm}
    \end{minipage}%
    \hfill%
\begin{minipage}[b]{0.5\linewidth}
        \includeDrawioFigure[\linewidth]{figures/r2c/avx-setup}[remember picture]{
            \path
            (Point1) coordinate (A)
            ([yshift=5pt] Point2) coordinate (B)
            (A) -- (B) coordinate[pos=.5] (M1)
            coordinate (BraceTip1) at ($ (M1)!{7pt+5pt}!-90:(B) $);
            \draw[decorate,decoration={brace,mirror,amplitude=7pt,raise=5pt}] (A) -- (B);
            \path
            ([yshift=5pt] Point2) coordinate (C)
            ([yshift=5pt] Point3) coordinate (D)
            (C) -- (D) coordinate[pos=.5] (M2)
            coordinate (BraceTip2) at ($ (M2)!{7pt+5pt}!-90:(D) $);
            \draw[decorate,decoration={brace,mirror,amplitude=7pt,raise=5pt}]
            (C) -- (D);
        }
    \end{minipage}
    \begin{tikzpicture}[remember picture, overlay]
        \draw[Latex-, line width=0.7] ([yshift=3pt]pic cs:T-First-Vex-Mov) -| ($ (pic cs:T-First-Vex-Mov)!0.4!(BraceTip1) $) |- ([xshift=-3pt]BraceTip1);
        \draw[Latex-, line width=0.7] ([yshift=3pt]pic cs:T-Second-Vex-Mov) -| ($ (pic cs:T-Second-Vex-Mov)!0.4!(BraceTip2) $) |- ([xshift=-3pt]BraceTip2);
    \end{tikzpicture}

    % --- ROW 2: CAPTIONS ---
    % This row contains the captions, aligned at their top edges.
    % The \subcaption command will work inside the minipage.
    \caption{\Gls{BTRA} setup with AVX2 instructions.
    The AVX2 instructions load the \glspl{BTRA} from a call-site specific array in the data section (\code{arr}) and write them to the stack in batch.}
    \label{r2c:fig:avx2-setup}

\end{figure}
Implementing the \gls{BTRA} setup with \code{push} instructions is conceptually straightforward, but exerts significant pressure on the instruction cache.
%    During the performance evaluation we noticed a performance impact particularly on call intensive benchmarks.
%    We speculate that the large number of instructions puts pressure on the instruction cache.
To improve \rtwoc{}'s performance, we built an optimized variant that sets up the \glspl{BTRA} and the return address with AVX2 vector instructions (see \cref{r2c:fig:avx2-setup})~\cite{IntelAVX}.

Before each call site, we initialize a vector register with \glspl{BTRA} and the return address and write them to the stack.
The addresses are read from a call-site specific array in the data section, prepared at compile time.
Regarding the security of reading the addresses from the data section, the same reason as for the \gls{GOT} holds.
After the \glspl{BTRA} and the return address are written to the stack, \rtwoc{} positions the stack pointer before the return address.
The \code{vmovdqa} instructions load the addresses from the data section into an AVX2 register.

The \code{vzeroupper} instruction is needed to eliminate a penalty when switching between SSE and AVX2 instructions.
Note that zeroing the upper half of the vector registers directly before a call does not affect program correctness.
Since the affected registers are caller saved, the caller has to save and restore them before a call anyway if they are used by subsequent basic blocks.
Without \code{vzeroupper} we observed a performance impact of up to 50\%.

We discuss the overall performance improvements afforded by the AVX2 instructions in \cref{r2c:ss:perf}.

\newsavebox{\uninstrumented}
\begin{lrbox}{\uninstrumented}

    \begin{lstlisting}[style=asmcode,breaklines=false]
|\raisebox{-1pt}[0pt][0pt]{$\vdots$}|

call F|\tikzmark{T-Right-Start}|

|\raisebox{-1pt}[0pt][0pt]{$\vdots$}|
    \end{lstlisting}
\end{lrbox}

\newsavebox{\instrumented}
\begin{lrbox}{\instrumented}

    \begin{lstlisting}[style=asmcode,breaklines=false,xleftmargin=2em]
|\tikzmark{T-Before-Begin}|push BTRA1
push BTRA2
|\tikzmark{T-Before-End}|push BTRA3
push BTRA3
|\tikzmark{T-After-Begin}|push BTRA5
|\tikzmark{T-After-End}|push BTRA6
add %rsp, |$(\beta+1)*8$|
call F
add %rsp, |$\alpha*8$|

    \end{lstlisting}
\end{lrbox}
\tikzset{
    pics/numberline/.style n args={4}{
        code = { %
            \coordinate (#3) at (0,0);
            \coordinate (#4) at (0,1);
            \draw (0,0) -- (0,1) ; %edit here for the axis
            \foreach \x in  {0.2,0.4,0.6,0.8} % edit here for the vertical lines
            \draw[shift={(0,\x)},color=black] (0,0) -- (0.05,0);
            \draw[color=black] (#3) -- (0.15,0);
            \draw[color=black] (#4) -- (0.15,1);
            \node at (0.4,0) {#1};
            \node at (0.4,1) {#2};
        }
    }
}


\begin{figure}[t]
    \centering
    \includegraphics[width=0.7\linewidth]{figures/r2c/btdp-setup}
    \caption[Naive vs.\ hardened \gls{heapbt} placement.]{An attacker could observe the \glspl{heapbt} \propername{S1}, \propername{S2} and \propername{S3} occurring in the data section \emph{and} on the stack (left, \textsf{naive}).
    In \rtwoc{} no single \gls{heapbt} occurs in both places (right).
    The \glspl{heapbt} \propername{X} and \propername{Y} mislead attempts to disclose the \gls{heapbt} array pointer from the data section (see \cref{r2c:ss:impl-heap-boobytraps}).}
    \label{r2c:fig:hardened-data-traps}
\end{figure}

\subsection{\texorpdfstring{\glspl{heapbt}}{BTDPs}: Booby-Trap Data Pointers}\label{r2c:ss:impl-heap-boobytraps}

\glspl{heapbt} aim to stop an attacker from following heap pointers found on the stack.
To maintain the illusion of a benign heap pointer, \glspl{heapbt} must have the same value range as real heap pointers, but at the same time cause a fault when being dereferenced.
Ideally, \glspl{heapbt} would point to random addresses on the heap that are protected by memory permissions.
Unfortunately, the Intel architecture currently does not offer subpage level permissions.
We therefore simulate the desired effect by letting \glspl{heapbt} point to random offsets within \emph{guard pages} allocated from heap memory.

Since heap memory is managed by the standard library (e.g. \propername{glibc}), these allocations cannot be performed at compile time.
Instead, \rtwoc{} registers a \emph{constructor function} that performs the allocations at program start.
Specifically, the constructor function allocates a configurable number of page-aligned and page-sized chunks of heap memory.
Next, the constructor function frees all but a randomly chosen subset of those allocations.
The remaining allocations are scattered randomly across the heap, are page aligned, and span an entire page.
\rtwoc{} stores pointers to random offsets within those allocations in a global pointer array in the data section.
To protect the newly created heap pointers from dereferencing, the constructor function revokes the read permission from the occupied page.
Allocating the guard pages with \code{malloc} without freeing them prevents \propername{glibc} from reusing the protected page for other allocations.

During compilation, \rtwoc{} instruments function prologs to write \glspl{heapbt} from the pointer array to the stack.
How many \glspl{heapbt} are written per function is chosen randomly using compile-time parameters.
The stack slots for the \glspl{heapbt} are allocated like stack slots for local variables during compilation.
As a result, stack slot randomization shuffles \glspl{heapbt} with other stack objects, including benign heap pointers.
\cref{r2c:lst:btdp-setup-code} shows the \glspl{heapbt} setup code in the prolog of a function.
Storing the \glspl{heapbt} to the stack requires $2*B+1$ instructions, where $B$ is the number of \glspl{heapbt}.
\cref{r2c:fig:btdp-stack} shows an example stack and heap with inserted \glspl{heapbt}.
Note that \glspl{heapbt} can point to arbitrary addresses within a guard page and multiple \glspl{heapbt} point to the same guard page.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/r2c/btdp-stack}
    \caption{Stack and heap with inserted \glspl{heapbt}.}
    \label{r2c:fig:btdp-stack}
\end{figure}

\begin{listing}[t]
    \begin{minted}{gas}
mov 0x4f04d7(%rip),%r11  // load the BTDP array pointer
mov 0x220(%r11),%rax     // load an array entry into rax
mov %rax,0x30(%rsp)      // store the pointer to a compile-time random slot
mov 0x600(%r11),%rax     // load another array entry into rax
mov %rax,0x20(%rsp)      // ...
mov 0x5b0(%r11),%rax
mov %rax,0x10(%rsp)
mov 0x1a0(%r11),%rax
    \end{minted}
    \caption{Example \glspl{heapbt} setup code in the prolog of a function.}
    \label{r2c:lst:btdp-setup-code}
\end{listing}

Storing the \glspl{heapbt} in the data section potentially poses a security risk.
If an attacker has access to the data section (\ie knows its location), she could compare heap pointers found in the data section with pointers observed on the stack (see \cref{r2c:fig:hardened-data-traps}).
Pointers observed in both locations could potentially\footnote{Points in both locations do not have to be \glspl{heapbt} because benign pointers can occur in both locations as well.} be \glspl{heapbt}.
To avoid the risk of triggering a \gls{heapbt}, an attacker could limit herself to pointers occurring on the stack only.
To protect \glspl{heapbt} against such an attack scenario, \rtwoc{} applies \rtwoc{}'s mimicry principle also to the array holding the \glspl{heapbt}.
Specifically, \rtwoc allocates the pointer array on the \emph{heap} and stores only a \emph{pointer to the array} in the data section.
That is, instead of containing the \glspl{heapbt} directly, the data section now contains only a single heap pointer (apart from application specific pointers).
Since an attacker might still be able to locate the pointer to the pointer array, \rtwoc inserts additional \glspl{heapbt} into the data section.
Note, that these additional \glspl{heapbt} never occur on the stack and the pointers on the heap are inaccessible to the attacker.
The attacker thus loses the ability to reliably identify the location of \glspl{heapbt} in the data section.
See \cref{r2c:fig:hardened-data-traps} for a comparison of a naive and a hardened implementation.

As a simple optimization, we omit the instrumentation for all functions without stack allocations.
Such functions are guaranteed to not write benign heap pointers to the stack either.
While this optimization over-approximates the set of functions to instrument, it still improves performance for simple functions (\eg accessors).
