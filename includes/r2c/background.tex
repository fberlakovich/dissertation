\section{Address-Oblivious Code Reuse}\label{r2c:s:aocr}
The \propername{Readactor} paper highlighted the risks of indirect \gls{JITROP} and proposed \emph{leakage-resilient diversity} through a mixture of software diversity, execute-only memory, and trampoline tables.
\glsfirst{AOCR} was introduced two years later and fundamentally challenged this security model.
Apart from an investigation of potential weaknesses in execute-only memory implementations, the \gls{AOCR} paper showed that pointers in readable memory remain a threat even when \gls{CPH} is used.
Beyond the general issue of whole-function pointer reuse, the \gls{CPH} trampoline table even enables an attacker to directly infer function pointers from return addresses, effectively turning the \gls{CPH} table into an unwilling accomplice.
Ultimately, even with execute-only memory and without the need for classic \gls{ROP} gadgets, a viable attack surface remains with or without \gls{CPH}.

While indirect JIT-ROP focuses on the discovery of gadgets, address-oblivious code reuse changes the reuse granularity from sub-function-level reuse to whole-function reuse.
As a result of this granularity change, defenses focusing on a lower granularity become ineffective.
Counterfeit object-oriented programming followed a similar strategy, making it immune against sub-function-level granularity defenses~\cite{Schuster2015a}

The \gls{AOCR} paper assumes the attacker possesses an arbitrary read-write memory corruption capability.
The \gls{AOCR} attack itself comprises two stages, a profiling stage to harvest valuable code pointers, followed by mounting the actual whole-function reuse attack.
To be usable in a whole-function reuse attack, function pointers must satisfy two criteria:
\begin{inline}
    \item they must point to a function useful to the attacker;
    \item the function's control-flow must be controllable via memory corruptions, \eg by corrupting their parameters.
    In their attack examples, the \gls{AOCR} authors exploit functions that read parameter values from memory.
    Examples for such functions are default parameter wrappers, which take fewer parameters than the original function and pass a default value read from memory to the original function.
\end{inline}

In the context of the categorization presented in \cref{ch:code-reuse-coevolution}, a memory-safety enforcement technique would aim to prevent the initial memory corruption.
\gls{CFI} on the other hand, would aim to prevent the whole-function pointer reuse.
Note, however, that because \gls{AOCR} does not involve gadget-level code reuse, coarse-grained \gls{CFI} such as Intel CET cannot prevent the attack.
A \gls{CFI}-based defense would also have to guarantee that the target function is not in the target set of an exploitable call site.
Finally, a randomization-based technique would target the profiling stage to prevent an attacker from reliably identifying function pointer locations.
Disrupting the reliable profiling of function pointer locations is where Readactor falls short.
Although function pointers on the stack are redirected through \gls{CPH}, their stack locations remain predictable.

\gls{AOCR} rests on the fact that existing randomization defenses primarily diversify code but leave the layout of observable \emph{data} intact.
\cref{r2c:fig:overview-unprotected-vs-protected} shows the information available to an attacker from an unprotected system.
Without protection, the global variables, the heap, and the stack remain predictable and contain enough information to mount a whole-function reuse attack.
Specifically, the attacks in the \gls{AOCR} paper demonstrate how an attacker can \Circled{\code{A}} profile pointer locations on the stack, \Circled{\code{B}} leak heap data to reach the data section, and \Circled{\code{C}} use the predictable data section layout to corrupt function default parameters (see \cref{r2c:fig:overview-unprotected-vs-protected}).

Among the observable data areas, the stack is particularly vulnerable.
The stack contains a large number of code pointers (return addresses and function pointers) as well as pointers to the heap and thus serves as a stepping stone to reach other data areas.
\gls{AOCR}'s Malicious Thread Blocking further allows an attacker to reliably observe the stack of a single thread.

Existing stack frame diversification techniques, like stack slot randomization, can hinder the exact profiling of function pointer locations~\cite{Jackson2011,Rodes2013,Aga2019}.
Unfortunately, the location of \emph{return addresses} remains predictable even in the presence of stack slot randomization.
The \gls{AOCR} authors also demonstrate that, unlike for code pointers, an attacker does not need an exact one-to-one mapping of data pointers to their targets.
Instead, a statistical analysis of pointers based on their value ranges can identify \emph{groups of pointers}, such as heap pointers, each of which leads to the desired data area.