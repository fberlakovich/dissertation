\section{The Design of \rtwoc}\label{r2c:s:design}

\begin{figure*}[t]
    \centering
    \begin{subfigure}[t]{0.6\linewidth}
        \figuretitle{Unprotected stack}
        \resizebox{\linewidth}{!}{%
        %\includesvg{img/architecture-overview}
            \includegraphics[trim={0.5cm 0 12.5cm 0},clip]{figures/r2c/architecture-overview-with-heap}%
        }
        \captionsetup{margin={0pt,0.3cm},oneside}
        \caption{In an unprotected stack frame the return address is at a predictable location surrounded by known values.}
        \label{r2c:fig:overview-stack-unprotected}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.6\linewidth}
        \figuretitle{Stack protected with \rtwoc{}}
        \resizebox{\linewidth}{!}{%
            \includegraphics[trim={12.5cm 0 0.5cm 0},clip]{figures/r2c/architecture-overview-with-heap}%
%            }
        }
        \captionsetup{margin={0.3cm,0pt},oneside}
        \caption{\rtwoc inserts Booby-Trapped Return Addresses to conceal the return address and thus protect it from disclosure.}
        \label{r2c:fig:overview-stack-protected}
    \end{subfigure}
    \caption{The stack layout of an unprotected stack (\emph{top}) and a stack protected by \rtwoc (\emph{bottom}). We assume the System V ABI on the x86\_64 platform.}
    \label{r2c:fig:overview-stack}
\end{figure*}

%    We observe that the predictable location of return addresses makes them vulnerable to disclosure.
%    Previous stack frame diversification techniques have focused on permuting stack objects and on inserting random paddings between the stack frames.
%    These techniques harden against the profiling of function pointers in \gls{AOCR}.
%    Return addresses, however, keep their relative position to other stack objects and remain vulnerable to disclosure.

%    maybe explain why hiding the return address with IH is a bad idea
\rtwoc is a leakage-resilient diversity defense against advanced code-reuse attacks.
As such, \rtwoc's main objective is to prevent information leakage that could help an attacker to undermine the effects of randomization.
As a first step, and under the protection of execute-only memory, \rtwoc randomizes the order of functions in the text section to thwart ROP and JIT-ROP attacks.
\rtwoc{} further aims to remove the building blocks of sophisticated code-reuse attacks such as indirect JIT-ROP and \gls{AOCR}:
\begin{enumerate}
[label={(\roman*)}]
    \item a predictable layout of global variables as a means to manipulate function arguments in a whole-function reuse attack;
    \item the stack as a source for code and heap pointer leaks.
\end{enumerate}
Similar to Readactor\plusplus, \rtwoc protects global variables by randomizing their order and by inserting random padding~\cite{Crane2015b}.
Protecting the stack against leakage is more challenging.
Stack data necessarily has to remain readable, which poses the question of how to protect information in plain sight.

%%% 20210507/0950/sbr/ccs2021.tex#595:
%%% reordered paragraphs to: highlight overall design, going deep into challenges, and closing how our overall design addresses these challenges!

To illustrate the challenges of protecting the stack, consider the unprotected stack frame in \cref{r2c:fig:overview-stack-unprotected}.
\cref{r2c:fig:overview-stack-unprotected} shows the stack frame of a function when called \emph{from} function \code{F} on the x86\_64 platform with the System V ABI calling convention.
When locating pointers on the stack, an attacker can tap two sources of information.
First, an attacker can leverage the predictable location of pointers relative to other stack objects.
If the adversary has information pertaining to some of these stack objects (\eg the value \code{0xaaaa} of a local variable \code{A} in function \code{F}), they can use this information as an anchor to locate the pointer.
For example, in \cref{r2c:fig:overview-stack-unprotected} the return address is one machine word below function variable \code{A} and adjacent to the spilled base pointer (\texttt{rbp}).
Second, an attacker can locate pointers based on their value ranges.
The heap pointer in \cref{r2c:fig:overview-stack-unprotected}, for example, has a different address range than code pointers or the spilled base pointer.
If both of these methods fail, an attacker can still resort to guessing.
Under specific circumstances, such brute-force attacks are a reasonable option; some servers restart crashed worker processes without reloading their binary code images (\eg nginx, Apache, OpenSSH)~\cite{Bittau2014a}.

The core idea behind \rtwoc's techniques is \emph{mimicry}: deliberately disguising sensitive information by surrounding it with similar-looking data, so that the real object cannot be distinguished using either spatial or semantic cues.
In practice, this means creating decoys that match the appearance and behavioral characteristics of the protected object.
For example, addresses that have the same alignment, size, and value-range properties as genuine return or heap pointers, and that are positioned unpredictably relative to other stack objects.
By making decoys and real pointers statistically and structurally similar, mimicry removes the usual anchors an attacker uses (predictable offsets, value ranges, and layout patterns) and forces an adversary to guess.
\rtwoc further penalizes guessing attempts with booby traps, which afford an attacker at most one incorrect guess.
Mimicry therefore raises the cost and risk of disclosure attacks while preserving normal program semantics for non-adversarial execution.

We instantiate this principle for return addresses and for heap pointers as follows:
\begin{enumerate}
[label=(\roman*)]
%    \vspace*{-0.5cm}
    \item So-called \emph{booby-trapped return addresses}, or \glspl{BTRA} for short, randomize the precise position of a return address in a stack frame.
    By inserting \glspl{BTRA}, \rtwoc changes the relative position of the return address to other stack objects.
    An attacker is, therefore, no longer able to rely on specific stack objects as anchor points to locate the return address.
    In addition, \glspl{BTRA} disguise the return address among enclosing and similar-looking values, as they are specifically chosen to look and behave exactly like benign return addresses.
    \glspl{BTRA} point to booby-trap functions randomly distributed in the text section.
    Without exact code-layout information, an adversary cannot separate \glspl{BTRA} from benign addresses.

    \item A combination of \emph{booby-trapped data pointers}, or \glspl{heapbt} for short, and stack slot randomization protects heap pointers against disclosure.
    Stack object permutation randomizes the position of heap pointers relative to other stack objects.
    The insertion of \glspl{heapbt} misleads \gls{AOCR}'s statistical analysis based on pointer value ranges.
    As \glspl{heapbt} point into the heap like benign heap pointers, both share the same value range.
    To protect against brute force attacks, \glspl{heapbt} point into guard pages.
    Dereferencing a \gls{heapbt} causes an immediate fault, giving defenders a way to respond to an ongoing attack.

\end{enumerate}

The following subsections give an in-detail presentation of the relevant design decisions and requirements.
First, we describe the details on inserting booby-trapped return addresses (see \Cref{r2c:ss:decoy-mimicry}).
Second, we explain how \glspl{heapbt} thwart the localization of heap pointers (see \Cref{r2c:ss:heap-boobytraps}).
Third, we illustrate how additional code randomization strengthens the protection afforded by \glspl{BTRA} and \glspl{heapbt} (see \Cref{r2c:ss:strengthening}).
Both \glspl{BTRA} and \glspl{heapbt} leverage the principle of mimicry, \ie disguising sensitive objects among covert booby traps.
In \cref{r2c:ss:speculative-booby-traps} we discuss an extension of this principle into the speculative domain.

\subsection{Booby-Trapped Return Addresses}\label{r2c:ss:decoy-mimicry}
An indispensable prerequisite for effective \glspl{BTRA} is that they must be virtually indistinguishable from actual, benign return addresses.
For \glspl{BTRA} to masquerade as return addresses, they must:
\begin{enumerate*}[label={(\roman*)}]
    \item look like return addresses;
    \item behave like return addresses;
    \item resist brute force attacks.
\end{enumerate*}

To achieve the first and the third goal, \glspl{BTRA} point to booby trap functions.
Booby trap functions are distributed randomly in the \emph{text section}, giving \glspl{BTRA} the same value range as benign return addresses.
Absent exact information about return addresses and leakage through side channels, an attacker could still apply brute-force.
\gls{BROP}, for example, demonstrates the effectiveness and feasibility of brute-force to learn the location of a \code{read} gadget~\cite{Bittau2014a}.
Booby traps provide an effective way to penalize such brute force attempts~\cite{Crane2013}.
In the context of \rtwoc, a classic \gls{BROP} attack is infeasible for two reasons:
\begin{enumerate*}[label={(\roman*)}]
    \item the booby trap functions distributed in the text section deter attempts to blindly locate gadgets with brute force;
    \item execute-only memory prevents \gls{BROP} from disclosing the text section with a found \texttt{read} gadget.
\end{enumerate*}
Likewise, brute forcing an attack with all return address candidates is improbable because all but one of the candidates lead to a booby trap function.
We discuss the combination of Blind ROP with the more powerful PIROP attack in \cref{r2c:sss:corrupting-code-pointers}.

To achieve the second goal, \glspl{BTRA} mimic the runtime behavior of return addresses.
Since return addresses are part of the control flow of a program, they show a distinct observable runtime behavior.
Recall the following properties of return addresses and call sites, which must also hold for booby-trapped return addresses:
\begin{enumerate}[label=(\Alph*)]
    \item \label{itm:raprop1} A return address occurs exactly once in the stack frame;
    \item \label{itm:raprop2} Multiple invocations of the same call site have the same return address;
    \item \label{itm:raprop3} Different call sites have different return addresses.
\end{enumerate}
% \glspl{BTRA} must have these properties as well.
Violating any of these properties might allow an attacker to learn the actual return address.
%%% 20201118/1654/sbr/sp2021-urad.tex#519: parallel sentence construction...
We take the following precautions to preserve the properties.
To preserve property~\ref{itm:raprop1}, \rtwoc{} ensures that each call site uses the same booby-trapped return address just once.
To preserve property~\ref{itm:raprop2}, \rtwoc{} does \emph{not} change the set of \glspl{BTRA} for a call site at run-time.
This decision represents a rare case, where \emph{more} dynamism is \emph{less} effective.
Consider a single call site with dynamically changing \glspl{BTRA}: just two observations suffice to identify the return address, as it is the only pointer remaining identical.
To preserve property~\ref{itm:raprop3},  \rtwoc{} inserts a randomly chosen set of \glspl{BTRA} at each \emph{call-site}.
If, instead, one were to insert them in the \emph{callee}, multiple call sites would have the identical set of \glspl{BTRA}, with only one difference: the return address.

For this very reason---preserving property~\ref{itm:raprop3}---\rtwoc{} also avoids reusing booby-trapped return addresses between different call sites as much as possible.
% \rtwoc also tries to avoid reusing \glspl{BTRA} between different call sites, as doing so would violate \cref{itm:raprop3}.
In particular, an attacker could leak multiple stack frames and look for recurring addresses to identify \glspl{BTRA}.
Due to the ensuing combinatorial explosion, avoiding the reuse of \glspl{BTRA} between call sites becomes increasingly difficult with an increasing number of call sites.
To counter this combinatorial effect, we tolerate occasional reuse and parameterize the maximum number of \glspl{BTRA}.
An attacker would have to leak two specific stack frames reusing the same \glspl{BTRA} to gain valuable information.
Such a leak is unlikely in practice because the \glspl{BTRA} are distributed randomly over the text section.

\subsection{Booby-Trapped Data Pointers}\label{r2c:ss:heap-boobytraps}
Contrary to return addresses, the runtime requirements for non-control-flow related stack objects are not as strict.
Stack objects like local variables, for example, can be permuted freely within the stack frame.
Such a reordering invalidates any a priori knowledge an attacker might have regarding the relative position of stack objects to each other.

Without the knowledge of stack object positions, an attacker can still resort to analyzing the value ranges of stack objects.
The \gls{AOCR} paper demonstrates that a statistical analysis of two pages of stack values suffices to reliably identify heap pointers.
Due to the large address space of x64 systems, the values of pointers occur in clusters, with heap pointers typically constituting the third-largest cluster.
To reach the heap, an attacker does not necessarily need to identify a \emph{specific} heap pointer.
Note, however, that thanks to stack slot randomization, an attacker also \emph{cannot} reliably identify a specific heap pointer.
Instead, an attacker has to pick and dereference an arbitrary pointer from the cluster of heap pointers.
\rtwoc{} uses this insight to penalize the random choice by mixing \glspl{heapbt} into the cluster of benign heap pointers.
\glspl{heapbt} point into randomly distributed guard pages on the heap, thus, sharing the same value range as benign heap pointers.
A statistical analysis will, thus, sort \glspl{heapbt} and benign heap pointers into a single cluster.
If an attacker dereferences a \gls{heapbt}, she causes a segmentation fault that can be handled by the program or a monitoring system.

\subsection{Strengthening \rtwoc Through Code Randomization}\label{r2c:ss:strengthening}
To strengthen security, \rtwoc diversifies the code layout at a subfunction granularity.
To this end, \rtwoc randomly inserts NOP instructions at call sites, traps in function prologs, and randomizes register allocation~\cite{Crane2015, Pappas2012a}.
By diversifying these function parts, two specific types of inference are impeded:
\begin{enumerate*}[label=(\roman*)]
    \item from return addresses to function addresses, and
    \item from function addresses to gadget locations.
\end{enumerate*}

The inserted NOPs at a call site change the relative offset between the return address and the calling function address.
As a result, an attacker can no longer reliably infer the function address from a leaked return address, effectively restricting the use of return addresses to \emph{gadget localization}.
Whereas for a whole-function reuse attack a \emph{single} function pointer might suffice, an attacker typically needs multiple leaked addresses to locate enough gadgets for a gadget chain.
Return addresses are protected by \glspl{BTRA} and increasing the number of required leaks increases the probability of an attacker choosing a \gls{BTRA} over the real return address.
Thus, increasing the number of required leaks increases the overall security.

The inserted traps in the prolog change the relative offset from the function start to a potential gadget location.
An attacker leaking a function pointer can, therefore, no longer reliably infer gadget locations and is restricted to \emph{whole-function reuse}.
Although in principle, a single leaked function pointer might suffice, whole-function reuse attacks have stricter requirements on the leaked function pointers (\eg corruptible default parameters).
Potential leaks are therefore less likely to meet those requirements.
%% Function pointers on the stack are also less frequent than return addresses and are also protected by stack slot randomization.
Compared with return addresses, function pointers on the stack occur less frequently and are, furthermore, protected by stack slot randomization.
% Instead of crashing the target process, booby traps can actively react to an ongoing attack.
% For example, a booby trap could prevent the restart of a crashed process, patch vulnerable code or start a honeypot process instead.




%%    \subsection{Adaptive Security}\label{r2c:ss:adaptive-security}
%%    \rtwoc provides probabilistic security against the disclosure of return addresses.
%%    Specifically, each inserted BTRA decreases the success rate of a blind guess, while increasing the necessity for more observations.
%%    At the same time, however, inserting additional BTRAs impacts the performance and code size.
%%    For that reason the number of BTRAs before and after the return address is configurable and can be tuned according to performance and security needs.
%%    There are several choices when choosing the number of BTRAs.
%%    One option is to use the same number for each call site.
%%    Another option is to randomly choose the number of BTRAs based on a configurable random trial.
%%    The performance of these variants is analyzed in \cref{s:eval}.
%%
%%    Static parameters or random selection do not take into account the different performance and security profiles of call sites.
%%    The power of adaptive security lies in the ability to control parameter selection with additional information.
%%    Programs, for example, typically spend most of their execution time in only few regions of the code, called hot regions~\cite{Pettis1990}.
%%    Adding more BTRAs to call sites in hot regions has a correspondingly bigger impact on performance than increasing BTRAs in cold regions.
%%    In \cref{r2c:ss:impl-pgo} we demonstrate how profiles can change the parameter selection based on the execution frequency of a call site.
%
%%    \fbetodo{Should we move this paragraph to discussion as future work?}
%%    Another option is to use application specific information.
%%    For instance, observe that stack frames are not equally vulnerable to information disclosure.
%%    To reliably leak a stack frame, the frame must occur in the call stack of a function blocked with Malicious Thread Blocking.
%%    Analogously, not all return addresses are equally desirable.
%%    Attackers are particularly interested in return addresses that reveal functions beneficial for an attack.
%%    Analyses uncovering these weak spots could drive the parameter selection to specifically harden the security of vulnerable call sites.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../eurosys22"
%%% End:
