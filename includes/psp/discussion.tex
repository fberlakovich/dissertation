\section{Discussion}\label{psp:s:discussion}
The median final edge coverage for \gls{VRP} configurations in \cref{psp:tab:coverage-fuzzbench} shows a mixed picture.
Only two benchmarks have a meaningfully large effect size, and among these two, the negative result (\propername{sqlite3\_ossfuzz}) dominates.
For the Magma benchmarks in \cref{psp:tab:coverage-magma}, the edge coverage disadvantage is more pronounced with six negatively affected benchmarks.
These results admit only a rejection of our first hypothesis.
\begin{infobox}
    \textbf{\ref{psp:hpt:vrp-coverage}}\hspace{0.8em}\ding{55}\\
    \gls{VRP} does \emph{not} improve the fuzzer's ability to discover new edges.
    In fact, \gls{VRP} leads to a disadvantage with respect to edge coverage for certain benchmarks.
\end{infobox}

For Call Unfolding, only two benchmarks show a statistically significant difference in \cref{psp:tab:coverage-fuzzbench}, but their effect size is too small to be meaningful.
In the Magma suite, Call Unfolding shows no statistically significant difference to the baseline at all.
The lack of differences leads us to reject also the second hypothesis.
\begin{infobox}
    \textbf{\ref{psp:hpt:unfold-coverage}}\hspace{0.8em}\ding{55}\\
    Call Unfolding does \emph{not} improve the fuzzer's ability to discover new edges.
    We observed no statistically significant differences to the baseline.
\end{infobox}

Finally, the bug triggering statistics in \cref{app:tab:magma-benchmarks} show no statistically significant difference except for two bugs, \propername{SND006} and \propername{TIF002}.
In both cases, \gls{VRP} leads to a measurable deterioration of bug triggering.
Based on these results we also have to reject the third hypothesis.
\begin{infobox}
    \textbf{\ref{psp:hpt:bugs}}\hspace{0.8em}\ding{55}\\
    \gls{PSP} transformations do \emph{not} improve bug-finding capability.
    In two cases, \gls{VRP} impeded the fuzzer's ability to trigger a bug.
\end{infobox}

The negative results naturally raise the question of \emph{why} \gls{PSP} fails to improve fuzzer performance and in some cases even hurts a fuzzer's progress.
The following subsections discuss possible root causes of the negative results.

\subsection{Execution Speed and Bitmap Size}
Both \gls{PSP} transformations insert additional instructions and with them additional edges.
\gls{VRP} causes a mean slowdown of 19\% and in the case of Magma's \propername{libsndfile} even 55\%.
In the case of Call Unfolding, the mean slowdown is around 0, with the worst benchmark at -24\%, but with \propername{sqlite3\_ossfuzz} showing an improvement of 30\%.
To test whether these observed slowdowns could possibly be a cause of the observed deterioration, we ranked the fuzzers by execution speed delta and by coverage change and computed the Pearson correlation between the two rankings.
For both \gls{VRP} and Call Unfolding the correlation coefficients were small, and the $p$ values (\num{0.495} and \num{0.161}) too large for statistical significance.
In other words, based on the data we have we cannot conclude that execution speed differences cause the differences in edge coverage.

To investigate whether the additional \gls{PSP} edges overflow the fuzzer's coverage bitmap, we measured the bitmap utilization across benchmarks.
We found that only 5 out of 43 benchmarks (FuzzBench and Magma) use more than 50\% of their bitmap, with \propername{openh264\_decoder\_fuzzer} reaching the most at 71\%.
This utilization suggests that an overflowing coverage bitmap is not the cause of \gls{PSP}'s negative results.

\subsection{Missing Initial Control-Flow}

\begin{listing}[t]
    \begin{minted}{C}

// Missing in buggy version
// if ((tmsize_t)sp->stream.avail_out > sp->tbuf_size)
// {
//   TIFFErrorExt(tif->tif_clientdata, module,
//        "sp->stream.avail_out > sp->tbuf_size");
//   return (0);
// }

do {
  int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
  if (state == Z_STREAM_END) {
    break;            /* XXX */
  }
// rest of loop
} while (sp->stream.avail_out > 0);

    \end{minted}
    \label{psp:lst:libtiff-bug}
    \caption{Heap overflow bug \propername{TIF002} in \propername{libtiff}.}
\end{listing}

Our current implementation of \gls{VRP} requires existing comparisons as starting points for further instrumentation.
Certain bugs, such as \propername{TIF002} in \propername{libtiff} of the Magma benchmark suite, lack such a comparison.
\cref{psp:lst:libtiff-bug} shows the relevant code snippet.
The heap overflow caused by \code{inflate} is only triggered when \code{sp->stream.avail\_out} is bigger than \code{sp->tbuf\_size}.
The relation between the two fields is entirely implicit, however.
In such cases \gls{VRP} does not instrument the affected code.
\gls{VRP} would need another mechanism, such as invariant inference to surface this relation, \eg in the form of an assertion.
Once the relation is materialized into control flow, \gls{VRP} could provide stepping stones for the fuzzer to eventually violate the invariant.

\subsection{Edge Entanglement}

A core assumption behind \gls{PSP} is that the additional edges give a value signal about a hitherto unknown program state to the fuzzer.
If, on the other hand, a newly discovered \gls{PSP} edge is a direct consequence of a simultaneously discovered baseline edge, the fuzzer gains no new information.
For each input that discovers new coverage, we can thus distinguish three different events:
\begin{enumerate}
    \item Only the baseline discovers the edge.
    Since the edges in our \gls{PSP} instrumented binaries are a \emph{superset} of the baseline, this event is impossible.
    \item Only the \gls{PSP} binary discovers the edge.
    \gls{PSP} has surfaced a program state that would otherwise have been invisible to the fuzzer.
    \item Both the baseline and the \gls{PSP} binary discover the edge.
    We call these edges entangled.
\end{enumerate}

We tested for edge entanglement by rerunning the corpus found by the baseline and the \gls{PSP} configurations and recorded for each input which edges it triggered.

- need to differentiate baseline from VRP edges

\subsection{Queue Explosion}

- how much energy does the fuzzer spend on VRP edges?
- how big are the queue and corpus sizes?
- how many dead VRP edges
- need to differentiate baseline from VRP edges
