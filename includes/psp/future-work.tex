\section{Future Work}

\subsection{Extending PSP to Other Analyses}
Program State Projection currently focuses on indirect call targets and value ranges.
However, compilers perform many other analyses that could expose hidden state:
\begin{itemize}
    \item \emph{Alias analysis} could distinguish executions where pointers alias from those where they do not.
    \item \emph{Escape analysis} could partition executions based on whether objects escape their allocating scope.
    \item \emph{Loop invariant detection} could expose whether values remain constant across loop iterations.
\end{itemize}
A systematic evaluation of which compiler analyses are most valuable for fuzzing and how to project their results onto the control-flow remains an open research question.

\subsection{Better heuristics}

Our evaluation in \cref{psp:s:evaluation} showed that at least the currently implemented \gls{PSP} heuristics are ineffective in helping a fuzzer achieve more coverage or bug triggering.
This does not mean, however, that \gls{PSP} cannot be effective with a different set of heuristics.
The following subsections discuss other potential heuristics following the \gls{PSP} principle.

\subsubsection{Approach Gradients}

\begin{figure}[t]
    \centering
    \begin{minipage}[t]{0.48\textwidth}
        \begin{minted}[fontsize=\footnotesize]{C}
void process_data(uint32_t x) {
  // other code manipulating x
  if (x > 12345) {
    if (x < 12345) {
      crash_program();
    }
  }
}
        \end{minted}
    \end{minipage}%
    \hfill
    \begin{minipage}[t]{0.48\textwidth}
        \begin{minted}[fontsize=\footnotesize]{C}
void process_data(uint32_t x) {
  // other code manipulating x
  if (x > 10000) {        // step 1
    if (x > 12000) {      // step 2
      if (x > 12345) {    // threshold
        if (x < 12890) {
          crash_program();
        }
      }
    }
  }
}
        \end{minted}
    \end{minipage}

    \begin{minipage}[t]{0.48\textwidth}
        \subcaption{Original code.}
        \label{psp:lst:approach-gradients}
    \end{minipage}%
    \hfill
    \begin{minipage}[t]{0.48\textwidth}
        \subcaption{After transformation.}
        \label{psp:lst:backward-gradients-transformed}
    \end{minipage}
    \caption{Backward gradients insert stepping stones that guide the fuzzer towards a hard-to-satisfy comparison threshold.}
    \label{psp:fig:backward-gradients}
\end{figure}

As discussed in \cref{psp:s:value-range-partitioning}, our \gls{VRP} instrumentation uses existing comparisons as a starting point to insert additional comparisons, partitioning the data space.
This approach falls short, however, if the starting point comparison itself is the obstacle that the fuzzer struggles to overcome.
Consider \cref{psp:lst:approach-gradients} as an example.
Our \gls{VRP} instrumentation would use the \code{x < 12890} comparison as a starting point and insert additional partitions between the two comparisons.
A fuzzer would still have to find an \code{x} value that passes the \code{x > 12345} comparison, however.
An alternative insertion heuristic could insert gradients \emph{approaching} the threshold from below, as shown in \cref{psp:lst:backward-gradients-transformed}.
When the fuzzer discovers an input with \code{x > 10000}, it gains a new edge; when it finds \code{x > 12000}, it gains another.
These intermediate edges guide the fuzzer towards the critical threshold at 12345.
Note that while this approach looks conceptually similar to \gls{VRP}, both have different goals, and they are in fact mutually beneficial.
The goal of \gls{VRP} is to help the fuzzer sample a variable's data space more evenly.
The goal of approach gradients is to gradually lead the fuzzer towards thresholds, such as the ones inserted by \gls{VRP}.

\subsubsection{Alternative Insertion Points}\label{psp:sss:insertion-points}
An alternative insertion heuristic is to choose an interesting program point, such as \emph{dataflow sinks}, and to move backwards from there.
Recall the example \cref{psp:lst:psp-no-transform} from \cref{psp:s:value-range-partitioning}.
Our heuristic would not instrument the code in \cref{psp:lst:psp-no-transform} because it does not contain a comparison as a starting point.
Interesting data flow sinks could be, for example, calls taking the variable in question as a parameter.
Such an approach to identifying instrumentation points is similar to the usage-based heuristics \propername{boundaries} and \propername{arithmetic}.
In the example in \cref{psp:lst:psp-no-transform}, we could reason that because the param value flows into a function call, it is relevant to the program.
A potential splitting point would then have to include as many of these potentially interesting dataflow sinks as possible.

\subsubsection{Value Relation Gradients}


\begin{figure}[t]
    \centering
    \begin{minipage}[t]{0.48\textwidth}
        \begin{minted}[fontsize=\footnotesize]{C}
void process(uint32_t A, uint32_t B) {
  if (A <= B) {
    crash_program();
  }
}
        \end{minted}
    \end{minipage}%
    \hfill
    \begin{minipage}[t]{0.48\textwidth}
        \begin{minted}[fontsize=\footnotesize]{C}
void process(uint32_t A, uint32_t B) {
  if (A <= B + 10000) {   // step 1
    if (A <= B + 1000) {  // step 2
      if (A <= B) {       // threshold
        crash_program();
      }
    }
  }
}
        \end{minted}
    \end{minipage}

    \begin{minipage}[t]{0.48\textwidth}
        \subcaption{Original code.}
        \label{psp:lst:value-relations}
    \end{minipage}%
    \hfill
    \begin{minipage}[t]{0.48\textwidth}
        \subcaption{After transformation.}
        \label{psp:lst:value-relations-transformed}
    \end{minipage}
    \caption{Relational gradients guide the fuzzer towards satisfying comparisons between two variables.}
    \label{psp:fig:value-relations}
\end{figure}

Our \gls{VRP} heuristics currently only insert gradients based on concrete values.
Certain bugs only trigger, however, if two or more variables have a certain value \emph{relative} to each other.
As an example, consider the code in \cref{psp:lst:value-relations}.
The bug triggers when variables \code{A} and \code{B} are in a certain relation to each other.
In such cases the split point heuristics we showed in \cref{psp:s:program-state-projection} are ineffective because the interesting thresholds are dictated by another variable and not by a usage or the type's value range.
Nonetheless, more powerful heuristics could handle such cases within the \gls{PSP} framework, \eg by subdividing the range \emph{between} the variables.
If, for example, variable \code{A} must be at most \code{B} to trigger the bug, \gls{PSP} could insert gradients that reward inputs where \code{A} approaches \code{B} from above, as shown in \cref{psp:lst:value-relations-transformed}.
