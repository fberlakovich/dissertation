%! root = thesis.tex

\begin{savequote}[8cm]
    \textlatin{Neque porro quisquam est qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit...}

    There is no one who loves pain itself, who seeks after it and wants to have it, simply because it is pain...
    \qauthor{--- Cicero's \textit{de Finibus Bonorum et Malorum}}
\end{savequote}


\chapter{\label{ch:1-intro}Introduction}

\minitoc


\section{Motivation}

The construction of software today relies on an ever-growing ecosystem of technologies and towers of abstractions.
For example, it is not uncommon for a browser to consist of more than X million lines of code\todo{Add reference}.
While this ecosystem enables developers to build software systems of unprecedented functionality, the increasing complexity also creates new challenges.
Software is supposed to be secure, fast, and reliable.
These goals, however, often conflict with one another.
Security measures like \gls{CFI} or randomization, for example, typically incur a non-negligible performance overhead.
Performance optimizations such as JIT compilation, on the other hand, increase the complexity and as a result, risk introducing both security vulnerabilities and potential failures.
This balancing act between security, performance, and reliability influences the choice of programming language.
Languages with higher levels of abstraction can rule out whole classes of security vulnerabilities (\eg through automatic memory management).
On the flipside, the increased comfort and safety afforded by higher abstraction often comes at the cost of decreased runtime performance.

\paragraph{Security}
The tradeoff between abstraction and performance explains, at least in part, why languages like C or \cpp still form the foundation of critical infrastructure.
The potential performance benefits\footnote{Not every program written in C or \cpp is automatically fast.} and the predictable and tight control over machine internals makes C and \cpp a popular choice for systems software.
However, C and \cpp are also notorious for their memory unsafety and more broadly for the pitfalls of undefined behavior.
These properties regularly lead to dangerous vulnerabilities, which make programs written in C and \cpp attractive targets for malicious actors --- with potentially disastrous consequences.\todo{cite high impact vulnerabilities}
Although the rising popularity of memory-safe, yet performant languages like Rust mitigates the issue of memory vulnerabilities, C and \cpp remain a popular choice.\todo{cite teobe index}
What is more, the vulnerabilities stemming from memory safety also threaten memory-safe parts of a program.\todo{Add reference to combining Rust with C}
Even if new software was written entirely in memory-safe languages from now on, there would still be millions of lines of C and \cpp code in production.
As a result, vulnerabilities in systems software will likely remain a reality in the years to come.

One class of popular security vulnerabilities is control-flow hijacking and within that class code-reuse attacks.
Code-reuse attacks hijack a program's control flow and subsequently reuse code already present in the target process.
This approach allows attackers to bypass defenses like \wox, which, thanks to widespread hardware support, have become a de facto standard.
Over the years, researchers have continuously refined code-reuse attacks and defenses.
Among the defenses, two broad categories have emerged:
\begin{enumerate*}
    \item enforcement-based defenses (\eg \gls{CFI});
    \item software diversity.
\end{enumerate*}
\gls{CFI} attempts to restrict a program's control-flow at runtime to the control-flow intended by the developer.
Various successful attacks demonstrate the difficulty of statically determining possible and intended control-flow transfers.\todo{cite papers}

Software diversity, on the other hand, tolerates control-flow diversions but attempts to restrict an attacker's maneuverability.
In particular, software diversity randomizes various aspects of a process (\eg code layout or data representation) to invalidate a-priori information an attacker has about its victim process.
With an undiversified program, an attacker can use an identical copy of the target as a map to plan his steps.
For example, with the exact code and its location in the victim known, an attacker can construct a \gls{ROP} chain a-priori.
Diversification, on the other hand, invalidates parts of the attacker's map, effectively transforming randomized program parts into unknown terrain.

With software diversity in place, the cat and mouse game between attackers and defenders has become an information game.
Whereas defenders try to conceal as much information about the process as possible, attackers use an array of tricks to leak information.
For example, the JIT ROP attack has demonstrated that code randomization alone cannot stop an attacker from learning about the process' code layout.
Similarly, indirect JIT ROP showed that not even code randomization in combination with execute-only memory protects against code reuse.

A code-reuse attack that proved to be particularly elusive, especially against software diversity, is \gls{AOCR}.
Similar to indirect JIT ROP, \gls{AOCR} brought to light the shortcomings of existing software-diversity defenses by leveraging non-randomized data to infer the target process code layout.
In the first part of this thesis, we demonstrate a new type of software-diversity based defense that combines code randomization with targeted data randomization.
This combination renders \gls{AOCR} as well as a range of other attacks relying on accurate information unreliable.
At the same time, our techniques incur only a moderate performance overhead.

\paragraph{Performance}
In contrast to C and \cpp, high-level dynamic programming languages like Python are a popular choice when expressive power and programmer productivity are more important than performance.
Nonetheless, the topic of optimizing Python has received considerable attention over the years.
A key obstacle in this optimization effort remains elusive, however: C extensions.
Language runtimes, whether they are based on an interpreter, a JIT compiler, or both, fall short of optimizing C extensions.
THe primary reason is that the optimizer cannot reason about the code hiding behind a C extension.
These optimizer blindspots lead to untapped performance potential in language runtimes interacting with C extensions.

In the second part of this thesis, we introduce a new interpreter-based optimization technique called Cross Module Quickening.
\gls{CMQ} leverages the untapped optimization potential by allowing C extensions to register highly-optimized operations on C extension-specific datatypes.


A good example of this tension is JIT compilation.
While JIT compilation has managed to lift the performance of dynamic languages such as JavaScript to unprecedented heights, JIT compilers significantly increase the attack surface and the overall complexity of software.



Given the constant threat of security vulnerabilities, the research community has continuously refined attacks and defenses.\todo{cite papers}
A class of attacks that prove to be particularly elusive are so called code-reuse attacks.
Broadly speaking, two lines of defense have emerged against this type of attack.
On the one side, various types of control-flow enforcement techniques attempt to restrict a program's control-flow at runtime to the control flow intended by the developer.
On the other side, software diversity tolerates control-flow hijacking, but restricts the attacker's room for maneuvering by randomizing various aspects of the program's structure.



\section{Contribution}

Sed in rhoncus lectus. Mauris vulputate purus non malesuada pulvinar. Curabitur ullamcorper hendrerit elit, id vulputate libero sagittis vel. Pellentesque ac faucibus est. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Integer venenatis, nisl eleifend pellentesque consequat, sem tortor malesuada ante, ut tincidunt elit tortor sit amet nunc.

Cras vehicula ipsum sit amet dui rutrum ultrices. Integer eu eleifend odio. Praesent tempor, libero id ullamcorper euismod, lectus diam lobortis mauris, id venenatis arcu sem vitae purus. Pellentesque luctus tristique metus quis mollis. Praesent ullamcorper neque velit, sed iaculis est convallis sit amet. Quisque nec massa ut magna lobortis imperdiet. Quisque rhoncus purus eget mollis aliquet. Donec vehicula viverra nisl, sed posuere turpis vulputate non. Donec malesuada, eros id interdum volutpat, ipsum orci luctus quam, non pulvinar urna ipsum eget purus. Nam hendrerit condimentum tristique.

Proin metus velit, tempor at fringilla non, dictum eu felis. Proin volutpat enim ut fermentum aliquam. Nam dictum nisi eu nisl viverra fermentum. Pellentesque tristique arcu non orci congue faucibus. Fusce sit amet nisl fringilla, feugiat turpis vitae, eleifend ante. Suspendisse elementum, lectus non pulvinar bibendum, lectus massa faucibus turpis, vitae porta risus sem quis metus. Maecenas id sapien et dui lobortis imperdiet nec eu mi. Quisque porttitor tincidunt nisi, eget sagittis orci. Nunc mattis erat malesuada facilisis viverra. Maecenas sodales iaculis nisi vel tincidunt. Morbi aliquet nibh ac facilisis consectetur. In ultrices libero quis massa porttitor cursus. Quisque suscipit ac tortor eget aliquet. Ut eget lacus vel orci viverra maximus at at purus.

Nam massa neque, varius nec suscipit id, cursus ac mi. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. In hac habitasse platea dictumst. Vivamus facilisis nunc quis dictum consectetur. Sed congue sed magna non auctor. Vestibulum accumsan sit amet erat non congue. Sed at condimentum mi, sed scelerisque urna. Etiam tristique pulvinar rutrum. Donec semper nulla vitae rutrum semper. Maecenas ultrices nibh at orci sodales tincidunt sit amet vitae arcu. Curabitur interdum tincidunt ipsum, nec tincidunt nunc dapibus in. Nunc sit amet elementum massa, ut ornare lacus. Vivamus convallis fringilla erat, non suscipit sapien convallis eu. Nunc viverra lectus sit amet turpis viverra, eget iaculis purus rhoncus.

Morbi eu lectus arcu. Sed fringilla dui ut magna commodo, a malesuada ante pellentesque. Donec ornare facilisis pellentesque. Nulla vitae fringilla velit. Nunc id tellus nisl. Maecenas pretium elit lectus, nec consectetur nunc vulputate et. Sed facilisis magna nec gravida hendrerit. Sed a cursus nisl, in rhoncus massa. Curabitur ut nibh interdum, tempor risus vel, scelerisque nibh. Mauris quis ipsum sed risus tempor convallis ut a eros.

