\section{Background}\label{s:background}

\subsection{Genetic Algorithms}
Our proposed solution for input mutation is based on a genetic algorithm~\cite{holland1992adaptation}.
In general, a genetic algorithm operates on a set of \emph{individuals}.
The set of individuals is called the \emph{population} and the algorithm iteratively mutates and evaluates the individuals.
The evaluation of each individual in a population yields a \emph{fitness} score to judge the individual's ability to reach some predefined goal.
Based on this score, the genetic algorithm creates a new \emph{generation} (the next population) whose individuals are mutated descendants of selected individuals from the previous generation.
The process of mutating individuals or combining individuals to form an individual of the new generation is sometimes called \emph{reproduction}.
A high fitness score raises the chance of the genetic algorithm choosing an individual for reproduction.
This selection process ensures that desirable individuals can pass their properties to more children while less desirable individuals might not reproduce at all.

\subsection{JIT Compiler Fuzzing}\label{ss:jit-compiler-fuzzing}

As most software is processed by a compiler at some point, and compiler bugs can have severe consequences, compiler fuzzing is of particular importance~\cite{Ma2023,Xu2023,yang2011}.
Compiler fuzzers face a number of specific challenges.
First, constructing valid inputs (\ie inputs that are not rejected at the parsing stage) typically requires specialized input generators.
Second, miscompilations, \ie incorrect compilations that neither crash the compiler nor the compiled program, but lead to compiled programs that deviate from the source program's semantics, are hard to detect.
Generic fuzzers typically use sanitizers to detect non-crashing, but faulty program states in their subjects.
Sanitizers cannot, however, detect miscompilations.
Third, like fuzzers in general, compiler fuzzers try to reach previously unexplored states in the state space of the compiler.
To that end, compiler fuzzers must be able to \emph{differentiate} such compiler states and \emph{steer input generation} towards new states.

JIT compilers face a specific fourth challenge:
When a JIT compiler runs as part of a virtual machine (VM), even valid input programs might run solely in the VM's interpreter, never being compiled and thus never reaching the actual fuzzing target.

Summarizing, JIT compiler fuzzers must solve the following problems:
\begin{problems}
    \item \label{problem_correct_inputs} How to generate inputs that are both syntactically correct and do not exit prematurely due to a semantic error?
    \item \label{problem_miscompilations} How to detect miscompilations?
    \item \label{problem_new_coverage} How to differentiate compiler states?
    \item \label{problem_steer_input} How to adjust the input generation to reach new states?
    \item \label{problem_compiled_inputs} How to generate inputs that are actually JIT compiled?
\end{problems}

\subsection{GraalVM}
\label{sec:graalvm}

We are studying compiler fuzzing in the context of GraalVM, a family of technologies for high-performance execution of programs written in various programming languages.\footnote{\url{https://www.graalvm.org}}

\subsubsection{The GraalVM compiler}
GraalVM features both just-in-time (JIT) and ahead-of-time (AOT) compilation of programs written in Java and other languages, such as Scala or Kotlin, that compile to Java virtual machine (JVM) bytecode.
GraalVM also includes the Truffle language implementation framework~\cite{wuerthinger2013truffle}.
Truffle allows users to obtain a JIT compiler for domain-specific languages or other programming languages by implementing an interpreter for the language's semantics.
The GraalVM project maintains Truffle implementations of several common languages including Python, JavaScript, and Ruby.
The common GraalVM compiler compiles all languages running on GraalVM (\eg Java, Truffle languages, Scala, and Kotlin) to machine code.
Thus, bugs in the compiler affect \emph{all} GraalVM languages, and the compiler's reliability is of utmost importance to the GraalVM project.

\subsubsection{GraalVM optimization log}\label{sss:graalvm-optimization-log}
The GraalVM compiler can generate an optimization log during compilation.
This log includes entries for every optimizing code transformation the compiler performs.
Full log entries include the compiler phase performing the optimization, the name of the optimization performed, and the source code location of the program position where the optimization was performed.
\Cref{fig:optimization_log} shows an example optimization log entry.
The log data is used by various debug tooling and can be exported as a text file in JSON format.

\begin{figure}
    \begin{minted}{json}
  "phaseName": "UseTrappingNullChecksPhase",
  "optimizations": [ {
      "optimizationName": "UseTrappingNullChecks",
      "eventName": "NullCheckInsertion",
      "position": {
        "HashCodeTest.hashCodeSnippet01(Object)": 1
      }
  } ]
    \end{minted}
    \caption{Example GraalVM compiler optimization log entry, describing the elimination of an explicit \texttt{null} check.}
    \label{fig:optimization_log}
\end{figure}

An abridged form of the optimization log only increments a counter for each optimization performed.
These counters have very low overhead compared to the full log or code coverage information.
Our current work aggregates the optimization counters for each compiled input program.
Future extensions could incorporate more information from the log, such as in which order two optimizations were applied.
