\section{GraalVM Compiler Fuzzing}
\label{sec:graalvm_fuzzing}

The main focus of this paper is the optimization-log coverage described in \cref{s:lool-design}.
As the GraalVM compiler already provides such an optimization-log, we illustrate the \lool principle on the example of the GraalVM compiler.
We discuss the applicability to other compilers in \cref{par:compiler-optimization-logs}.

To solve some of the issues discussed in \cref{ss:jit-compiler-fuzzing}, we built a new fuzzer that specifically targets the GraalVM compiler.
Since our fuzzer differs in certain aspects from existing Java fuzzers, we describe the relevant details in the following sections.

\subsection{Input Program Generation}\label{ss:input-program-generation}
Our fuzzer generates Java source code with a custom Java source-code generator.
This generator is based on the liveness-driven random code generation approach~\cite{barany2017livenessdriven}.
In this approach, all values computed by the program are guaranteed to be used by following statements in the program.
This avoids unused computations being trivially eliminated by the compiler, thus increasing the density of \enquote{interesting} code per test case.
Our generator ensures syntactically and semantically correct inputs by design, solving \cref{problem_correct_inputs}.

Our generator supports a large subset of Java, including:
\begin{itemize}
    \item class structures: multiple classes with inheritance, multiple methods per class with overriding of inherited methods, \texttt{enum} classes, both \texttt{static} and non-\texttt{static} fields in classes;
    \item statements: assignments, \texttt{if} statements, \texttt{while} and \texttt{for} loops including \texttt{break} and \texttt{continue}, \texttt{synchronized} blocks;
    \item expressions: use of method parameters, class fields, local variables, array elements (inside \texttt{for} loops only); arithmetic, comparison, logic, and conditional expressions;
    \item method calls: calls to methods defined in the same generated program, to a helper library, or to a small list of explicitly allowed pure methods from the Java standard library.
\end{itemize}
The likelihood of generating each of these features and their exact form (\eg the number of classes and methods generated or maximum statement depth) is parameterizable.
We call a set of such parameters a \emph{parameter vector}.

Our generator also combines the above features, such as loops and arrays, into certain patterns, such as map-style \texttt{for} loops (\ie loops that read an input array, compute on each element, and write corresponding elements of a result array).
Such patterns enable specific optimizations~\cite{Livinskii2020}.

The generated programs include a \texttt{main} method that calls other generated methods and prints their results.
The inputs to these calls are embedded in the code as constants or are pseudo-randomly generated by the helper library, with a fixed seed per program.
The helper library included with each program also contains methods for printing and hashing of data for which Java's default \texttt{toString} and \texttt{hashCode} methods do not provide deterministic behavior across runs.
Thus we generate fully self-contained, stand-alone programs that print the same deterministic data on each run.
The generator itself uses a pseudo-random number generator and embeds the seed as a comment in the program for easy reproduction.

\subsection{Test Execution}
\begin{figure}[t]
    \resizebox{0.7\columnwidth}{!}{%
    %\includesvg{img/architecture-overview}
        \includegraphics{figures/lool/architecture-noicons}%
    }
    \caption{Overview of the GraalVM fuzzing framework (see \cref{sec:graalvm_fuzzing})}
    \label{fig:fuzzing-framework-overview}
\end{figure}

Our fuzzer tests the generated programs using a test harness that compiles the Java source code to bytecode with \propername{javac} and loads the bytecode classes.
\cref{fig:fuzzing-framework-overview} gives an overview of the test execution.
First, the harness receives the generated program from the input generator \Circled{\texttt{1}} (see \cref{ss:input-program-generation}).
The harness executes the program's \texttt{main} method in the Java bytecode interpreter and records its output as the reference output \Circled{\texttt{2}}.
Running the interpreter prior to the compilation, but within the same VM instance, has two advantages:
\begin{enumerate}
    \item The interpreted run warms up the VM's profiles, which guide certain compiler decisions.
    Compilation of methods with warmed up profiles resembles real-world compilations more faithfully.
    We found certain profile-dependent bugs only due to the warmed up profiles.
    \item The test program has to run in the interpreter only once.
    In contrast, many Java fuzzers interpret a test program twice: once in interpreter-only mode and once with both the interpreter and the JIT compiler enabled.
    Thus, the test program runs entirely in the interpreter the first time and at least partially during the second run, until the hot methods are eventually JIT-compiled~\cite{JavaFuzzer,Li2023a,Wu2023}.
    Such an approach is more time-consuming due to the (initially) slower execution of interpreted code.
    More importantly, with such an approach only certain parts of the test program actually reach the JIT compiler.
\end{enumerate}

After interpreting the test program, the harness compiles methods in the program with the GraalVM compiler \Circled{\texttt{3}}.
The harness compiles all methods starting from \texttt{main} up to a certain call graph depth and installs the compiled code as the default.
The explicit compilation of methods with existing profiles avoids the need for specific code patterns to trigger JIT compilation.
As all later executions of the test program execute the \emph{compiled} methods, this compilation step solves \cref{problem_compiled_inputs}, \ie inputs not reaching the JIT compiler.
Finally, the harness executes the \texttt{main} method again, this time using the newly GraalVM-compiled methods, and compares the output to the reference output \Circled{\texttt{4}}.

The harness detects crashes of the GraalVM compiler and mismatches in the outputs of the reference and compiled runs, and reports these as errors.
The differential testing against the interpreter solves \cref{problem_miscompilations}, \ie detection of miscompilations.

\begin{figure}
% GR-53391, Test_0_86
    \begin{minted}{java}
public static void main(String[] args) {
    double var12 = 95.5965959289008;
    double var13;
    for (int i2 = 527935578; i2 <= 527935876; i2 = i2 + 3) {
        var13 = i2;
        var12 = var12 - Math.log10(Long.sum(1706025860L, (long) var13));
    }
    GraalDirectives.deoptimize();
}
    \end{minted}
    \caption{Example bug after test case reduction. The GraalVM compiler crashed while compiling this method.}
    \label{fig:example_bug}
\end{figure}

This fuzzing framework has been in regular use within the GraalVM project for four years.
It has been effective at finding both miscompilations and bugs that crash the compiler with failed assertions or unexpected exceptions being thrown.

We use the existing source code reducers Perses~\cite{Sun2018} and C-Reduce~\cite{regehr2012} to reduce programs that provoke errors to minimal versions for easier debugging.
\cref{fig:example_bug} shows an example of a reduced, crashing compiler bug found by the GraalVM fuzzer without optimization log coverage.
