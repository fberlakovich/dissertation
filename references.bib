@inproceedings{berlakovich2024,
    title = {Cross {{Module Quickening}} - {{The Curious Case}} of {{C Extensions}}},
    author = {Berlakovich, Felix and Brunthaler, Stefan},
    booktitle = {38th {{European Conference}} on {{Object-Oriented Programming}} ({{ECOOP}} 2024)},
    location = {Dagstuhl, Germany},
    publisher = {Schloss Dagstuhl --- Leibniz-Zentrum f{\"u}r Informatik},
    series = {Leibniz {{International Proceedings}} in {{Informatics}} ({{LIPIcs}})},
    volume = 313,
    pages = {6:1--6:29},
    doi = {10.4230/LIPIcs.ECOOP.2024.6},
    isbn = {978-3-95977-341-6},
    issn = {1868-8969},
    url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.6},
    urldate = {2025-06-12},
    editor = {Aldrich, Jonathan and Salvaneschi, Guido},
    date = 2024,
}

@inproceedings{Shacham2007,
    title = {{The geometry of innocent flesh on the bone}},
    author = {Shacham, Hovav},
    year = 2007,
    booktitle = {Proceedings of the 14th ACM conference on Computer and communications security - CCS '07},
    publisher = {ACM Press},
    address = {New York, New York, USA},
    volume = 22,
    number = 4,
    pages = 552,
    doi = {10.1145/1315245.1315313},
    isbn = 9781595937032,
    issn = 15437221,
    abstract = {We present new techniques that allow a return-into-libc attack to be mounted on x86 executables that calls no functions at all. Our attack combines a large number of short instruction sequences to build gadgets that allow arbitrary computation. We show how to discover such instruction sequences by means of static analysis. We make use, in an essential way, of the properties of the x86 instruction set.},
}

@inproceedings{Crane2015,
    title = {{Readactor: Practical Code Randomization Resilient to Memory Disclosure}},
    shorttitle = {Readactor},
    author = {Crane, Stephen and Liebchen, Christopher and Homescu, Andrei and Davi, Lucas and Larsen, Per and Sadeghi, Ahmad-Reza and Brunthaler, Stefan and Franz, Michael},
    year = 2015,
    month = may,
    booktitle = {2015 IEEE Symposium on Security and Privacy},
    publisher = {IEEE},
    volume = {2015-July},
    pages = {763--780},
    doi = {10.1109/SP.2015.52},
    isbn = {978-1-4673-6949-7},
    issn = 10816011,
    abstract = {--Code-reuse attacks such as return-oriented pro-gramming (ROP) pose a severe threat to modern software. Designing practical and effective defenses against code-reuse attacks is highly challenging. One line of defense builds upon fine-grained code diversification to prevent the adversary from constructing a reliable code-reuse attack. However, all solutions proposed so far are either vulnerable to memory disclosure or are impractical for deployment on commodity systems. In this paper, we address the deficiencies of existing solutions and present the first practical, fine-grained code randomization defense, called Readactor, resilient to both static and dynamic ROP attacks. We distinguish between direct memory disclosure, where the attacker reads code pages, and indirect memory disclosure, where attackers use code pointers on data pages to infer the code layout without reading code pages. Unlike previous work, Readactor resists both types of memory disclosure. Moreover, our technique protects both statically and dynamically generated code. We use a new compiler-based code generation paradigm that uses hardware features provided by modern CPUs to enable execute-only memory and hide code pointers from leakage to the adversary. Finally, our extensive evaluation shows that our approach is practical--we protect the entire Google Chromium browser and its V8 JIT compiler--and efficient with an average SPEC CPU2006 performance overhead of only 6.4{\%}.},
    annote = {XO Memory indirect memory disclosure code pointer hiding (stack und heap)}
}

@inproceedings{Crane2015b,
    title = {{It's a TRaP}},
    author = {Crane, Stephen and Franz, Michael and Volckaert, Stijn and Schuster, Felix and Liebchen, Christopher and Larsen, Per and Davi, Lucas and Sadeghi, Ahmad-Reza and Holz, Thorsten and {De Sutter}, Bjorn},
    year = 2015,
    booktitle = {Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security - CCS '15},
    publisher = {ACM Press},
    address = {New York, New York, USA},
    pages = {243--255},
    doi = {10.1145/2810103.2813682},
    isbn = 9781450338325,
    issn = 15437221,
    abstract = {Code-reuse attacks continue to evolve and remain a severe threat to modern software. Recent research has proposed a variety of defenses with differing security, efficiency, and practicality characteristics. Whereas the majority of these solutions focus on specific code-reuse attack variants such as return-oriented programming (ROP), other attack variants that reuse whole functions, such as the classic return-into-libc, have received much less attention. Mitigating function-level code reuse is highly challenging because one needs to distin-guish a legitimate call to a function from an illegitimate one. In fact, the recent counterfeit object-oriented programming (COOP) attack demonstrated that the majority of code-reuse defenses can be bypassed by reusing dynamically bound func-tions, i.e., functions that are accessed through global offset tables and virtual function tables, respectively. In this paper, we first significantly improve and simplify the COOP attack. Based on a strong adversarial model, we then present the design and implementation of a compre-hensive code-reuse defense which is resilient against reuse of dynamically-bound functions. In particular, we introduce two novel defense techniques: (i) a practical technique to randomize the layout of tables containing code pointers re-silient to memory disclosure and (ii) booby trap insertion to mitigate the threat of brute-force attacks iterating over the randomized tables. Booby traps serve the dual purpose of preventing fault-analysis side channels and ensuring that each table has sufficiently many possible permutations. Our detailed evaluation demonstrates that our approach is secure, effective, and practical. We prevent realistic, COOP-style attacks against the Chromium web browser and report an av-erage overhead of 1.1{\%} on the SPEC CPU2006 benchmarks.},
}

@inproceedings{Snow2013b,
    title = {{Just-In-Time Code Reuse: On the Effectiveness of Fine-Grained Address Space Layout Randomization}},
    author = {Snow, K. Z. and Monrose, F. and Davi, L. and Dmitrienko, A. and Liebchen, C. and Sadeghi, A.},
    year = 2013,
    month = may,
    booktitle = {2013 IEEE Symposium on Security and Privacy},
    publisher = {IEEE},
    pages = {574--588},
    doi = {10.1109/SP.2013.45},
    isbn = {978-0-7695-4977-4}
}

@inproceedings{Backes2014f,
    title = {{Oxymoron: Making Fine-Grained Memory Randomization Practical by Allowing Code Sharing}},
    author = {Backes, Michael and N{\"{u}}rnberger, Stefan},
    year = 2014,
    booktitle = {Proceedings of the 23rd {USENIX} Conference on Security Symposium},
    publisher = {{USENIX} Association},
    address = {USA},
    series = {SEC'14},
    pages = {433--447},
    isbn = {978-1-931971-15-7},
    abstract = {The latest effective defense against code reuse attacks is fine-grained, per-process memory randomization. However, such process randomization prevents code sharing since there is no longer any identical code to share between processes. Without shared libraries, however, tremendous memory savings are forfeit. This drawback may hinder the adoption of fine-grained memory randomization.We present Oxymoron, a secure fine-grained memory randomization technique on a per-process level that does not interfere with code sharing. Executables and libraries built with Oxymoron feature 'memory-layout-agnostic code', which runs on a commodity Linux. Our theoretical and practical evaluations show that Oxymoron is the first solution to be secure against just-in-time code reuse attacks and demonstrate that fine-grained memory randomization is feasible without forfeiting the enormous memory savings of shared libraries.}
}

@inproceedings{Backes2014b,
    title = {{You Can Run but You Can't Read}},
    author = {Backes, Michael and Holz, Thorsten and Kollenda, Benjamin and Koppe, Philipp and N{\"{u}}rnberger, Stefan and Pewny, Jannik},
    year = 2014,
    booktitle = {Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security - CCS '14},
    publisher = {ACM Press},
    address = {New York, New York, USA},
    pages = {1342--1353},
    doi = {10.1145/2660267.2660378},
    isbn = 9781450329576,
    issn = 15437221,
    abstract = {Code reuse attacks allow an adversary to impose malicious behavior on an otherwise benign program. To mitigate such attacks, a common approach is to disguise the address or content of code snippets bymeans of randomization or rewrit- ing, leaving the adversary with no choice but guessing. How- ever, disclosure attacks allow an adversary to scan a process-- even remotely--and enable her to read executable memory on-the-fly, thereby allowing the just-in-time assembly of ex- ploits on the target site. In this paper, we propose an approach that fundamentally thwarts the root cause of memory disclosure exploits by pre- venting the inadvertent reading of code while the code itself can still be executed. We introduce a new primitive we call Execute-no-Read (XnR) which ensures that code can still be executed by the processor, but at the same time code cannot be read as data. This ultimately forfeits the self-disassembly which is necessary for just-in-time code reuse attacks (JIT- ROP) to work. To the best of our knowledge, XnR is the first approach to prevent memory disclosure attacks of exe- cutable code and JIT-ROP attacks in general. Despite the lack of hardware support for XnR in contemporary Intel x86 and ARMprocessors, our software emulations for Linux and Windows have a run-time overhead of only 2.2{\%} and 3.4{\%}, respectively.},
}

@inproceedings{Giontaa2015,
    title = {{HideM: Protecting the contents of userspace memory in the face of disclosure vulnerabilities}},
    author = {Gionta, Jason and Enck, William and Ning, Peng},
    year = 2015,
    booktitle = {CODASPY 2015 - Proceedings of the 5th ACM Conference on Data and Application Security and Privacy},
    pages = {325--336},
    doi = {10.1145/2699026.2699107},
    isbn = 9781450331913,
    abstract = {Memory disclosure vulnerabilities have become a common component for enabling reliable exploitation of systems by leaking the contents of executable data. Previous research towards protecting executable data fromdisclosure has failed to gain popularity due to large performance penalties and required architectural changes. Other research has focused on protecting application data but fails to consider a vul- nerable application that leaks its own executable data. In this paper we presentHideM, a practical system for pro- tecting against memory disclosures in contemporary com- modity systems. HideM addresses limitations in existing ad- vanced security protections (e.g., fine-grained ASLR, CFI) wherein an adversary discloses executable data from mem- ory, reasons about protection weaknesses, and builds cor- responding exploits. HideM uses the split-TLB architec- ture, commonly found in CPUs, to enable fine-grained exe- cute and read permission on memory. HideM enforces fine- grained permission based on policy generated from binary structure thus enabling protection of Commercial-Off-The- Shelf (COTS) binaries. In our evaluation of HideM, we find application overhead ranges from a 6.5{\%} increase to a 2{\%} reduction in runtime and observe runtime memory overhead ranging from 0.04{\%} to 25{\%}. HideM requires adversaries to guess ROP gadget locations making exploitation unreliable. We find adversaries have less than a 16{\%} chance of correctly guessing a single gadget across all 28 evaluated applications. Thus, HideM is a practical system for protecting vulnerable applications which leak executable data.},
}

@inproceedings{Tang2015,
    title = {{Heisenbyte}},
    author = {Tang, Adrian and Sethumadhavan, Simha and Stolfo, Salvatore},
    year = 2015,
    booktitle = {Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security - CCS '15},
    publisher = {ACM Press},
    address = {New York, New York, USA},
    volume = {2015-Octob},
    pages = {256--267},
    doi = {10.1145/2810103.2813685},
    isbn = 9781450338325,
    issn = 15437221,
    abstract = {Vulnerabilities that disclose executable memory pages en-able a new class of powerful code reuse attacks that build the attack payload at runtime. In this work, we present Heisenbyte, a system to protect against memory disclosure attacks. Central to Heisenbyte is the concept of destructive code reads â€“ code is garbled right after it is read. Gar-bling the code after reading it takes away from the attacker her ability to leverage memory disclosure bugs in both static code and dynamically generated just-in-time code. By lever-aging existing virtualization support, Heisenbyte's novel use of destructive code reads sidesteps the problem of incom-plete binary disassembly in binaries, and extends protection to close-sourced COTS binaries, which are two major limi-tations of prior solutions against memory disclosure vulner-abilities. Our experiments demonstrate that Heisenbyte can tolerate some degree of imperfect static analysis in disas-sembled binaries, while effectively thwarting dynamic code reuse exploits in both static and JIT code, at a modest 1.8{\%} average runtime overhead due to virtualization and 16.5{\%} average overhead due to the destructive code reads.},
}

@inproceedings{Werner2016,
    title = {{No-Execute-After-Read}},
    author = {Werner, Jan and Baltas, George and Dallara, Rob and Otterness, Nathan and Snow, Kevin Z and Monrose, Fabian and Polychronakis, Michalis},
    year = 2016,
    booktitle = {Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security - ASIA CCS '16},
    publisher = {ACM Press},
    address = {New York, New York, USA},
    pages = {35--46},
    doi = {10.1145/2897845.2897891},
    isbn = 9781450342339,
    abstract = {Memory disclosure vulnerabilities enable an adversary to successfully mount arbitrary code execution attacks against applications via so-called just-in-time code reuse attacks, even when those applications are fortified with fine-grained address space layout random-ization. This attack paradigm requires the adversary to first read the contents of randomized application code, then construct a code reuse payload using that knowledge. In this paper, we show that the recently proposed Execute-no-Read (XnR) technique fails to prevent just-in-time code reuse attacks. Next, we introduce the design and implementation of a novel memory permission primitive, dubbed No-Execute-After-Read (NEAR), that foregoes the problems of XnR and provides strong security guarantees against just-in-time attacks in commodity binaries. Specifically, NEAR allows all code to be disclosed, but prevents any disclosed code from subsequently being executed, thus thwarting just-in-time code reuse. At the same time, commodity binaries with mixed code and data regions still operate correctly, as legitimate data is still readable. To demonstrate the practicality and portability of our approach we implemented prototypes for both Linux and Android on the ARMv8 architecture, as well as a prototype that protects unmodified Mi-crosoft Windows executables and dynamically linked libraries. In addition, our evaluation on the SPEC2006 benchmark demonstrates that our prototype has negligible runtime overhead, making it suitable for practical deployment.}
}

@inproceedings{Snow2016,
    title = {{Return to the Zombie Gadgets: Undermining Destructive Code Reads via Code Inference Attacks}},
    author = {Snow, Kevin Z. and Rogowski, Roman and Werner, Jan and Koo, Hyungjoon and Monrose, Fabian and Polychronakis, Michalis},
    year = 2016,
    month = may,
    booktitle = {2016 IEEE Symposium on Security and Privacy (SP)},
    publisher = {IEEE},
    pages = {954--968},
    doi = {10.1109/SP.2016.61},
    isbn = {978-1-5090-0824-7},
    issn = {0096-140X},
    abstract = {The concept of destructive code reads is a new defensive strategy that prevents code reuse attacks by coupling finegrained address space layout randomization with a mitigation for online knowledge gathering that destroys potentially useful gadgets as they are disclosed by an adversary. The intuition is that by destroying code as it is read, an adversary is left with no usable gadgets to reuse in a control-flow hijacking attack. In this paper, we examine the security of this new mitigation. We show that while the concept initially appeared promising, there are several unforeseen attack tactics that render destructive code reads ineffective in practice. Specifically, we introduce techniques for leveraging constructive reloads, wherein multiple copies of native code are loaded into a process' address space (either side-by-side or one-afteranother). Constructive reloads allow the adversary to disclose one code copy, destroying it in the process, then use another code copy for their code reuse payload. For situations where constructive reloads are not viable, we show that an alternative, and equally powerful, strategy exists: leveraging code association via implicit reads, which allows an adversary to undo in-place code randomization by inferring the layout of code that follows already disclosed bytes. As a result, the implicitly learned code is not destroyed, and can be used in the adversary's code reuse attack. We demonstrate the effectiveness of our techniques with concrete instantiations of these attacks against popular applications. In light of our successes, we argue that the code inference strategies presented herein paint a cautionary tale for defensive approaches whose security blindly rests on the perceived inability to undo the application of in-place randomization},
}

@incollection{Morton2017,
    title = {{Defeating Zombie Gadgets by Re-randomizing Code upon Disclosure}},
    author = {Morton, Micah and Koo, Hyungjoon and Li, Forrest and Snow, Kevin Z and Polychronakis, Michalis and Monrose, Fabian},
    year = 2017,
    booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
    volume = {10379 LNCS},
    pages = {143--160},
    doi = {10.1007/978-3-319-62105-0_10},
    isbn = 9783319621043,
    issn = 16113349,
    abstract = {Over the past few years, return-oriented programming (ROP) attacks have emerged as a prominent strategy for hijacking control of software. The full power and flexibility of ROP attacks was recently demonstrated using just-in-time ROP tactics (JIT-ROP), whereby an adversary repeatedly leverages a memory disclosure vulnerability to identify useful instruction sequences and compile them into a functional ROP payload at runtime. Since the advent of just-in-time code reuse attacks, numerous proposals have surfaced for mitigating them, the most practical of which involve the re-randomization of code at runtime or the destruction of gadgets upon their disclosure. Even so, several avenues exist for performing code inference, which allows JIT-ROP attacks to infer values at specific code locations without directly reading the memory contents of those bytes. This is done by reloading code of interest or implicitly determining the state of randomized code. These so-called ``zombie gadgets'' completely undermine defenses that rely on destroying code bytes once they are read. To mitigate these attacks, we present a low-overhead, binary-compatible defense which ensures an attacker is unable to execute gadgets that were identified through code reloading or code inference. We have implemented a prototype of the proposed defense for closed-source Windows binaries, and demonstrate that our approach effectively prevents zombie gadget attacks with negligible runtime overhead.},
}

@inproceedings{Davi2015,
    title = {{Isomeron: Code Randomization Resilient to (Just-In-Time) Return-Oriented Programming}},
    shorttitle = {Isomeron},
    author = {Davi, Lucas and Liebchen, Christopher and Sadeghi, Ahmad-Reza and Snow, Kevin Z. and Monrose, Fabian},
    year = 2015,
    booktitle = {Proceedings 2015 Network and Distributed System Security Symposium},
    publisher = {Internet Society},
    address = {Reston, VA},
    doi = {10.14722/ndss.2015.23262},
    isbn = {1-891562-38-X},
    issn = {1545-5971},
    abstract = {--Until recently, it was widely believed that code randomization (such as fine-grained ASLR) can effectively mit-igate code reuse attacks. However, a recent attack strategy, dubbed just-in-time return oriented programming (JIT-ROP), circumvents code randomization by disclosing the (randomized) content of many memory pages at runtime. In order to remedy this situation, new and improved code randomization defenses have been proposed. The contribution of this paper is twofold: first, we conduct a security analysis of a recently proposed fine-grained ASLR scheme that aims at mitigating JIT-ROP based on hiding direct code references in branch instructions. In particular, we demon-strate its weaknesses by constructing a novel JIT-ROP attack that is solely based on exploiting code references residing on the stack and heap. Our attack stresses that designing code randomization schemes resilient to memory disclosure is highly challenging. Second, we present a new and hybrid defense approach, dubbed Isomeron, that combines code randomization with execution-path randomization to mitigate conventional ROP and JIT-ROP attacks. Our reference implementation of Isomeron neither requires source code nor a static analysis phase. We evaluated its efficiency based on SPEC benchmarks and discuss its effectiveness against various kinds of code reuse attacks.},
    annote = {diversifier erstellt zwei diversifizierte kopien vom programm im memory calls und returns werden zu diversifier umgeleitet diversifier entscheidet zuf{\"{a}}llig, welche kopie angesprungen wird kopien haben gadgets an unterschiedlichen stellen},
    language = {en}
}

@inproceedings{Bittau2014a,
    title = {{Hacking Blind}},
    author = {Bittau, Andrea and Belay, Adam and Mashtizadeh, Ali and Mazi{\`{e}}res, David and Boneh, Dan},
    year = 2014,
    month = may,
    booktitle = {2014 IEEE Symposium on Security and Privacy},
    publisher = {IEEE},
    pages = {227--242},
    doi = {10.1109/SP.2014.22},
    isbn = {978-1-4799-4686-0},
    issn = 10816011,
    abstract = {We show that it is possible to write remote stack buffer overflow exploits without possessing a copy of the target binary or source code, against services that restart after a crash. This makes it possible to hack proprietary closed-binary services, or open-source servers manually compiled and installed from source where the binary remains unknown to the attacker. Traditional techniques are usually paired against a particular binary and distribution where the hacker knows the location of useful gadgets for Return Oriented Programming (ROP). Our Blind ROP (BROP) attack instead remotely finds enough ROP gadgets to perform a write system call and transfers the vulnerable binary over the network, after which an exploit can be completed using known techniques. This is accomplished by leaking a single bit of information based on whether a process crashed or not when given a particular input string. BROP requires a stack vulnerability and a service that restarts after a crash. We implemented Braille, a fully automated exploit that yielded a shell in under 4,000 requests (20 minutes) against a contemporary nginx vulnerability, yaSSL + MySQL, and a toy proprietary server written by a colleague. The attack works against modern 64-bit Linux with address space layout randomization (ASLR), no-execute page protection (NX) and stack canaries.}
}

@inproceedings{Crane2013,
    title = {{Booby trapping software}},
    author = {Crane, Stephen and Larsen, Per and Brunthaler, Stefan and Franz, Michael},
    year = 2013,
    booktitle = {Proceedings of the 2013 workshop on New security paradigms workshop - NSPW '13},
    publisher = {ACM Press},
    address = {New York, New York, USA},
    pages = {95--106},
    doi = {10.1145/2535813.2535824},
    isbn = 9781450325820,
    abstract = {Cyber warfare is asymmetric in the current paradigm, with attackers having the high ground over defenders. This asymmetry stems from the situation that attackers have the initiative, while defenders concentrate on passive fortifications. Defenders are constantly patching the newest hole in their defenses and creating taller and thicker walls, without placing guards on those walls to watch for the enemy and react to attacks. Current passive cyber security defenses such as intrusion detection, anti-virus, and hardened software are not sufficient to repel attackers. In fact, in conventional warfare this passivity would be entirely nonsensical, given the available active strategies, such as counterattacks and deception. Based on this observation, we have identified the technique of booby trapping software. This extends the arsenal of weaponry available to defenders with an active technique for directly reacting to attacks. Ultimately, we believe this approach will restore some of the much sought after equilibrium between attackers and defenders in the digital domain. Copyright 2013 ACM.},
    language = {en}
}

@inproceedings{WilliamsKing2016,
    title = {{Shuffler: Fast and Deployable Continuous Code Re-Randomization}},
    author = {Williams-King, David and Gobieski, Graham and Williams-King, Kent and Blake, James P and Yuan, Xinhao and Colp, Patrick and Zheng, Michelle and Kemerlis, Vasileios P and Yang, Junfeng and Aiello, William},
    year = 2016,
    month = nov,
    booktitle = {12th {USENIX} Symposium on Operating Systems Design and Implementation ({OSDI} 16)},
    publisher = {{USENIX} Association},
    address = {Savannah, GA},
    pages = {367--382},
    isbn = {978-1-931971-33-1},
    abstract = {While code injection attacks have been virtually eliminated on modern systems, programs today remain vulnerable to code reuse attacks. Particularly pernicious are Just-In-Time ROP (JIT-ROP) techniques, where an attacker uses a memory disclosure vulnerability to discover code gadgets at runtime. We designed a code-reuse defense, called Shuffler, which continuously re-randomizes code locations on the order of milliseconds, introducing a real-time deadline on the attacker. This deadline makes it extremely difficult to form a complete exploit, particularly against server programs that often sit tens of milliseconds away from attacker machines. Shuffler focuses on being fast, self-hosting, and nonintrusive to the end user. Specifically, for speed, Shuffler randomizes code asynchronously in a separate thread and atomically switches from one code copy to the next. For security, Shuffler adopts an ``egalitarian'' principle and randomizes itself the same way it does the target. Lastly, to deploy Shuffler, no source, kernel, compiler, or hardware modifications are necessary. Evaluation shows that Shuffler defends against all known forms of code reuse, including ROP, direct JITROP, indirect JIT-ROP, and Blind ROP. We observed 14.9{\%} overhead on SPEC CPU when shuffling every 50 ms, and ran Shuffler on real-world applications such as Nginx. We showed that the shuffled Nginx scales up to 24 worker processes on 12 cores.},
    mendeley-tags = {read}
}

@inproceedings{Goktas2020,
    author = {G{\"{o}}kta{}},
    address = {New York, NY, USA},
    abstract = {To defeat ASLR or more advanced fine-grained and leakage-resistant code randomization schemes, modern software exploits rely on information disclosure to locate gadgets inside the victim's code. In the absence of such info-leak vulnerabilities, attackers can still hack blind and derandomize the address space by repeatedly probing the victim's memory while observing crash side effects, but doing so is only feasible for crash-resistant programs. However, high-value targets such as the Linux kernel are not crash-resistant. Moreover, the anomalously large number of crashes is often easily detectable. In this paper, we show that the Spectre era enables an attacker armed with a single memory corruption vulnerability to hack blind without triggering any crashes. Using speculative execution for crash suppression allows the elevation of basic memory write vul-nerabilities into powerful speculative probing primitives that leak through microarchitectural side effects. Such primitives can repeatedly probe victim memory and break strong randomization schemes without crashes and bypass all deployed mitigations against Spectre-like attacks. The key idea behind speculative probing is to break Spectre mitigations using memory corruption and resurrect Spectre-style disclosure primitives to mount practical blind software exploits. To showcase speculative probing, we target the Linux kernel, a crash-sensitive victim that has so far been out of reach of blind attacks, mount end-to-end exploits that compromise the system with just-in-time code reuse and data-only attacks from a single memory write vulnerability, and bypass strong Spectre and strong randomization defenses. Our results show that it is crucial to consider synergies between different (Spectre vs. code reuse) threat models to fully comprehend the attack surface of modern systems. CCS CONCEPTS extbullet{} Security and privacy ightarrow{} Operating systems security.}
}
Interpreting "-" as stdin. NOTICE: as of v1.10.0 "-" can be omitted and will be invalid in v2. Stdin is read when no input file is specified.

@inproceedings{berlakovich2022a,
    title = {Look {{Ma}}, No Constants: Practical Constant Blinding in {{GraalVM}}},
    shorttitle = {Look {{Ma}}, No Constants},
    author = {Berlakovich, Felix and Neugschwandtner, Matthias and Barany, Gerg\"{o}},
    booktitle = {Proceedings of the 15th {{European Workshop}} on {{Systems Security}}},
    location = {New York, NY, USA},
    publisher = {Association for Computing Machinery},
    series = {{{EuroSec}} '22},
    pages = {36--42},
    doi = {10.1145/3517208.3523751},
    isbn = {978-1-4503-9255-6},
    url = {https://dl.acm.org/doi/10.1145/3517208.3523751},
    urldate = {2026-01-28},
    date = {2022-04-05},
    abstract = {With the advent of JIT compilers, code-injection attacks have seen a revival in the form of JIT spraying. JIT spraying enables an attacker to inject gadgets into executable memory, effectively sidestepping W\oplus{}X and ASLR.In response to JIT spraying, constant blinding has emerged as a conceptually straightforward and performance friendly defense. Unfortunately, increasingly sophisticated attacks have pinpointed the shortcomings of existing constant blinding implementations.In this paper we present our constant blinding implementation in the GraalVM compiler, enabling constant blinding across a wide range of languages. Our implementation takes insights from the last decade of research on the security of constant blinding into account. We discuss important design decisions and trade-offs as well as the practical implementation issues encountered when implementing constant blinding for GraalVM. We evaluate the performance impact of our implementation with different configurations and demonstrate its effectiveness by fuzzing for unblinded constants.},
}

@inproceedings{berlakovich2023,
    title = {{{R2C}}: {{AOCR-Resilient Diversity}} with {{Reactive}} and {{Reflective Camouflage}}},
    shorttitle = {{R2C}},
    author = {Berlakovich, Felix and Brunthaler, Stefan},
    booktitle = {Proceedings of the {{Eighteenth European Conference}} on {{Computer Systems}}},
    location = {New York, NY, USA},
    publisher = {Association for Computing Machinery},
    series = {{{EuroSys}} '23},
    pages = {488--504},
    doi = {10.1145/3552326.3587439},
    isbn = {978-1-4503-9487-1},
    url = {https://doi.org/10.1145/3552326.3587439},
    urldate = {2025-06-06},
    date = {2023-05-08},
    abstract = {Address-oblivious code reuse, AOCR for short, poses a substantial security risk, as it remains unchallenged. If neglected, adversaries have a reliable way to attack systems, offering an operational and profitable strategy. AOCR's authors conclude that software diversity cannot mitigate AOCR, because it exposes fundamental limits to diversification.Reactive and reflective camouflage, or R2C for short, is a full-fledged, LLVM-based defense that thwarts AOCR by combining code and data diversification with reactive capabilities through booby traps. R2C includes optimizations using AVX2 SIMD instructions, compiles complex real-world software, such as browsers, and offers full support of C++. R2C thus proves that AOCR poses no fundamental limits to software diversification, but merely indicates that code diversification without data diversification is a dead end.An extensive evaluation along multiple dimensions proves the practicality of R2C. We evaluate the impact of our defense on performance, and find that R2C shows low performance impacts on compute-intensive benchmarks (6.6 -- 8.5\% geometric mean on SPEC CPU 2017). A security evaluation indicates R2C's resistance against different types of code-reuse attacks.}
}

@inproceedings{schwarcz2024,
    title = {{{LOOL}}: {{Low-Overhead}}, {{Optimization-Log-Guided Compiler Fuzzing}} ({{Registered Report}})},
    shorttitle = {{LOOL}},
    author = {Schwarcz, Florian and Berlakovich, Felix and Barany, Gerg\"{o} and M\"{o}ssenb\"{o}ck, Hanspeter},
    booktitle = {Proceedings of the 3rd {{ACM International Fuzzing Workshop}}},
    location = {New York, NY, USA},
    publisher = {Association for Computing Machinery},
    series = {{{FUZZING}} 2024},
    pages = {42--51},
    doi = {10.1145/3678722.3685533},
    isbn = {979-8-4007-1112-1},
    url = {https://dl.acm.org/doi/10.1145/3678722.3685533},
    urldate = {2025-09-22},
    date = {2024-09-13},
    abstract = {Compiler fuzzing with randomly generated input programs is a powerful technique for finding compiler crashes and miscompilation bugs. Existing fuzzers for compilers are often unguided and must be manually parameterized to cover different parts of the compiler under test. In this work we present LOOL, an approach for fuzzing a compiler with low overhead, guided by optimization log information produced by the compiler. The optimization log tracks program transformations performed by the compiler on the level of individual methods compiled. We argue that using the optimization log has less overhead than off-the-shelf code coverage tools. At the same time, the optimization log's per-method data gives more information than code coverage collected over a number of distinct compilations. The level of detail of the optimization log is also easy to tune for the use case of guiding a fuzzer. We are integrating the LOOL approach in an existing fuzzer for the GraalVM compiler. A genetic optimization algorithm uses optimization log information for tuning code generation parameters with the goal of covering optimizations that were previously rarely exercised. Initial experiments confirm that varying the generator's parameters is effective at finding new bugs. The genetic algorithm will automate the exploration of the parameter space to improve testing of currently insufficiently fuzzed parts of the compiler.},
}

@article{berlakovich2026,
    title = {{{LOOL}}: {{Low-Overhead}}, {{Optimization-Log-Guided Compiler Fuzzing}}},
    shorttitle = {{LOOL}},
    author = {Berlakovich, Felix and Schwarcz, Florian and Barany, Gerg\"{o} and M\"{o}ssenb\"{o}ck, Hanspeter and Brunthaler, Stefan},
    year = 2026,
    journal = {ACM Transactions on Software Engineering and Methodology},
    note = {To appear},
}