import argparse
import math
from pathlib import Path

import pandas as pd


def build_dataframe(input_file):
    metrics = dict()
    with open(input_file) as f:
        for line in f:
            if not line[0].isalnum():
                continue
            split = line.rsplit("=", 1)
            metric = split[0].split("_")[1] if "_" in split[0] else split[0]
            if len(metric) > 35:
                continue
            value = int(split[1])
            metrics[metric] = value

    whitelist = ["LoopPeeling", "LoopVectorization"]
    metrics = dict(
        [
            metric
            for idx, metric in enumerate(
                sorted(metrics.items(), key=lambda item: item[1])
            )
            if metric[0] in whitelist or idx < 20 or idx % 4 == 0
        ]
    )
    df = pd.DataFrame.from_dict(metrics, orient="index", columns=["Count"])
    return df


def generate_tikz(df, xmin=10):
    """Generate a tikz figure with pre-calculated label positions.

    Styling is minimal - the importing document can customize via:
    - optimizationbar/.style for the bars
    - optimizationlabel/.style for the labels
    """

    # Sort descending for display
    df = df.sort_values(by="Count", ascending=False)

    lines = []
    lines.append(r"% Auto-generated by optimizationcounts.py")
    lines.append(r"% Customize styles in importing document:")
    lines.append(r"%   \pgfplotsset{optimizationbar/.style={...}}")
    lines.append(r"%   \tikzset{optimizationlabel/.style={...}}")
    lines.append(r"\begin{tikzpicture}")
    lines.append(r"\begin{axis}[")
    lines.append(r"    xbar,")
    lines.append(r"    xmode=log,")
    lines.append(f"    xmin={xmin},")
    lines.append(r"    ytick=data,")
    lines.append(r"    yticklabels={")

    # Add y-tick labels
    labels = [f"        {name}" for name in df.index]
    lines.append(",\n".join(labels))

    lines.append(r"    },")
    lines.append(r"    optimizationchart,  % apply custom style")
    lines.append(r"]")

    # Add bar plot data
    lines.append(r"\addplot+[optimizationbar] coordinates {")
    for idx, (name, row) in enumerate(df.iterrows()):
        lines.append(f"    ({row['Count']},{idx})")
    lines.append(r"};")

    # Add centered labels with pre-calculated positions
    lines.append(r"")
    lines.append(r"% Centered labels (positions pre-calculated)")
    for idx, (name, row) in enumerate(df.iterrows()):
        count = row['Count']
        # Geometric center on log scale: sqrt(xmin * value)
        center_x = math.sqrt(xmin * count)
        lines.append(f"\\node[optimizationlabel] at (axis cs:{center_x:.2f},{idx}) {{\\num{{{count}}}}};")

    lines.append(r"\end{axis}")
    lines.append(r"\end{tikzpicture}")

    return "\n".join(lines)


parser = argparse.ArgumentParser(
    description="Plot optimization counts",
    formatter_class=argparse.RawTextHelpFormatter,
)

parser.add_argument("input_file", type=str, help="Input file (optimizationcounts.txt)")
parser.add_argument("--latex-output", type=str, default=None, help="LaTeX output directory.")

args = parser.parse_args()

df = build_dataframe(args.input_file)
df.index.name = "Optimization"

if args.latex_output is not None:
    output_dir = Path(args.latex_output)

    # Generate tikz figure
    tikz_content = generate_tikz(df)
    with open(output_dir / "optimizationcounts.tex", "w") as f:
        f.write(tikz_content)

    # Also save the data file
    df_sorted = df.sort_values(by="Count", ascending=False)
    df_sorted.to_csv(output_dir / "optimizationcounts.dat", sep="\t", header=True, index=True)

    print(f"Written to {output_dir / 'optimizationcounts.tex'}")
    print(f"Written to {output_dir / 'optimizationcounts.dat'}")
else:
    # Just print to stdout
    print(generate_tikz(df))
